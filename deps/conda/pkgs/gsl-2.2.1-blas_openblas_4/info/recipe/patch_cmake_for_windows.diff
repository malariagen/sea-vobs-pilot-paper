From aa3e97971dadf222a93d89fce4af4dd583bb3457 Mon Sep 17 00:00:00 2001
From: shadow_walker <shadowwalkersb@gmail.com>
Date: Sun, 18 Dec 2016 22:56:49 -0600
Subject: [PATCH] Update GSL to version 2.2.1

---
 CMakeLists.txt                 |  695 ++++++++++++++++++++++++
 appveyor.yml                   |    8 +
 cmake/c_flag_overrides.cmake   |    6 +
 cmake/cxx_flag_overrides.cmake |    6 +
 cmake/init.cmake               |   92 ++++
 doc/examples/expfit.c          |   56 ++
 doc/multifit.texi              | 1170 ++++++++++++++++++++++++++++++++++++++++
 gsl.pc.cmake                   |   11 +
 ieee-utils/fp-win.c            |   70 +++
 9 files changed, 2114 insertions(+)
 create mode 100644 CMakeLists.txt
 create mode 100644 appveyor.yml
 create mode 100644 cmake/c_flag_overrides.cmake
 create mode 100644 cmake/cxx_flag_overrides.cmake
 create mode 100644 cmake/init.cmake
 create mode 100644 doc/examples/expfit.c
 create mode 100644 doc/multifit.texi
 create mode 100644 gsl.pc.cmake
 create mode 100644 ieee-utils/fp-win.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..8882549
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,695 @@
+# CMake build script for the GNU Scientific Library.
+
+# Use CMake 2.8.3 for CMakeParseArguments.
+cmake_minimum_required(VERSION 2.8.3)
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/cmake)
+include(init)
+
+project(GSL)
+
+if (POLICY CMP0054)
+  # Only interpret `if` arguments as variables or keywords when unquoted.
+  cmake_policy(SET CMP0054 NEW)
+endif ()
+
+set(PACKAGE "gsl")
+set(PACKAGE_NAME ${PACKAGE})
+set(PACKAGE_TARNAME ${PACKAGE})
+set(PACKAGE_BUGREPORT "")
+set(PACKAGE_URL "")
+set(LT_OBJDIR ".libs/")
+
+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
+
+# The following part of config.h is hard to derive from configure.ac.
+string(REGEX MATCHALL "[^\n]*\n" CONFIG
+"/* Define if you have inline with C99 behavior */
+#undef HAVE_C99_INLINE
+
+/* Define to 1 if you have the declaration of `acosh', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ACOSH
+
+/* Define to 1 if you have the declaration of `asinh', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ASINH
+
+/* Define to 1 if you have the declaration of `atanh', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ATANH
+
+/* Define to 1 if you have the declaration of `expm1', and to 0 if you don't.
+   */
+#undef HAVE_DECL_EXPM1
+
+/* Define to 1 if you have the declaration of `feenableexcept', and to 0 if
+   you don't. */
+#undef HAVE_DECL_FEENABLEEXCEPT
+
+/* Define to 1 if you have the declaration of `fesettrapenable', and to 0 if
+   you don't. */
+#undef HAVE_DECL_FESETTRAPENABLE
+
+/* Define to 1 if you have the declaration of `finite', and to 0 if you don't.
+   */
+#undef HAVE_DECL_FINITE
+
+/* Define to 1 if you have the declaration of `fprnd_t', and to 0 if you
+   don't. */
+#undef HAVE_DECL_FPRND_T
+
+/* Define to 1 if you have the declaration of `frexp', and to 0 if you don't.
+   */
+#undef HAVE_DECL_FREXP
+
+/* Define to 1 if you have the declaration of `hypot', and to 0 if you don't.
+   */
+#undef HAVE_DECL_HYPOT
+
+/* Define to 1 if you have the declaration of `isfinite', and to 0 if you
+   don't. */
+#undef HAVE_DECL_ISFINITE
+
+/* Define to 1 if you have the declaration of `isinf', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ISINF
+
+/* Define to 1 if you have the declaration of `isnan', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ISNAN
+
+/* Define to 1 if you have the declaration of `ldexp', and to 0 if you don't.
+   */
+#undef HAVE_DECL_LDEXP
+
+/* Define to 1 if you have the declaration of `log1p', and to 0 if you don't.
+   */
+#undef HAVE_DECL_LOG1P
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+#undef HAVE_DOPRNT
+
+/* Defined if you have ansi EXIT_SUCCESS and EXIT_FAILURE in stdlib.h */
+#undef HAVE_EXIT_SUCCESS_AND_FAILURE
+
+/* Defined on architectures with excess floating-point precision */
+#undef HAVE_EXTENDED_PRECISION_REGISTERS
+
+/* Define if x86 processor has sse extensions. */
+#undef HAVE_FPU_X86_SSE
+
+/* Define to 1 if you have the <ieeefp.h> header file. */
+#undef HAVE_IEEEFP_H
+
+/* Define this if IEEE comparisons work correctly (e.g. NaN != NaN) */
+#undef HAVE_IEEE_COMPARISONS
+
+/* Define this if IEEE denormalized numbers are available */
+#undef HAVE_IEEE_DENORMALS
+
+/* Define if you have inline */
+#undef HAVE_INLINE
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the `memmove' function. */
+#undef HAVE_MEMMOVE
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define this if printf can handle %Lf for long double */
+#undef HAVE_PRINTF_LONGDOUBLE
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strdup' function. */
+#undef HAVE_STRDUP
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if you have the `strtoul' function. */
+#undef HAVE_STRTOUL
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `vprintf' function. */
+#undef HAVE_VPRINTF
+
+/* Define if you need to hide the static definitions of inline functions */
+#undef HIDE_INLINE_STATIC
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Defined if this is an official release */
+#undef RELEASED
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define to 1 if type `char' is unsigned and you are not using gcc.  */
+#ifndef __CHAR_UNSIGNED__
+# undef __CHAR_UNSIGNED__
+#endif
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+#undef volatile
+")
+
+# Get version numbers and parts of config.h from configure.ac.
+file(READ configure.ac LINES)
+# Replace semicolons with "<semi>" to avoid CMake messing with them.
+string(REPLACE ";" "<semi>" LINES "${LINES}")
+# Split into lines keeping newlines to avoid foreach skipping empty ones.
+string(REGEX MATCHALL "[^\n]*\n" LINES "${LINES}")
+set(ah_command FALSE)
+foreach (line "${EXTRA_CONFIG}" ${LINES})
+  string(REPLACE ";" "" line "${line}")
+  if (ah_command)
+    # Do nothing.
+  elseif (line MATCHES "AC_INIT[^,]*,\\[(.*)\\].*")
+    set(VERSION ${CMAKE_MATCH_1})
+    message(STATUS "Got VERSION=${VERSION} from configure.ac")
+  elseif (line MATCHES "((GSL|CBLAS)_(CURRENT|REVISION|AGE))=(.*)\n")
+    set(${CMAKE_MATCH_1} ${CMAKE_MATCH_4})
+    message(STATUS "Got ${CMAKE_MATCH_1}=${CMAKE_MATCH_4} from configure.ac")
+  elseif (line MATCHES "AH_BOTTOM\\(\\[(.*)")
+    set(ah_command bottom)
+    set(line "${CMAKE_MATCH_1}")
+  elseif (line MATCHES "AH_VERBATIM[^,]+,(.*)")
+    set(ah_command verbatim)
+    set(line "${CMAKE_MATCH_1}")
+  endif ()
+  if (ah_command)
+    set(saved_ah_command ${ah_command})
+    if (line MATCHES "^\\[(.*)")
+      set(line "${CMAKE_MATCH_1}")
+    endif ()
+    if (line MATCHES "\\]\\)")
+      set(ah_command FALSE)
+      string(REPLACE "])" "" line "${line}")
+    endif ()
+    # For some reason CMake may bundle several lines together. Split them too.
+    string(REGEX MATCHALL "[^\n]*\n" sublines "${line}")
+    set(config_add "")
+    foreach (subline ${sublines})
+      set(config_add ${config_add} "${subline}")
+    endforeach ()
+    if (saved_ah_command STREQUAL "verbatim")
+      set(CONFIG ${config_add} ${CONFIG})
+    else ()
+      set(CONFIG ${CONFIG} "\n" ${config_add})
+    endif ()
+  endif ()
+endforeach ()
+set(PACKAGE_VERSION ${VERSION})
+set(PACKAGE_STRING "${PACKAGE} ${VERSION}")
+
+if (NOT (VERSION MATCHES "\\+"))
+  # Defined if this is an official release.
+  set(RELEASED /**/)
+endif ()
+
+include(CheckLibraryExists)
+check_library_exists(m cos "" HAVE_LIBM)
+if (HAVE_LIBM)
+  set(CMAKE_REQUIRED_LIBRARIES m)
+endif ()
+
+include(CheckCSourceCompiles)
+
+# Check for inline.
+foreach (keyword inline __inline__ __inline)
+  check_c_source_compiles("
+    static ${keyword} void foo() { return 0; }
+    int main() {}" C_HAS_${keyword})
+  if (C_HAS_${keyword})
+    set(C_INLINE ${keyword})
+    break ()
+  endif ()
+endforeach ()
+if (C_INLINE)
+  # Check for GNU-style extern inline.
+  check_c_source_compiles("
+    extern ${C_INLINE} double foo(double x);
+    extern ${C_INLINE} double foo(double x) { return x + 1.0; }
+    double foo(double x) { return x + 1.0; }
+    int main() { foo(1.0); }" C_EXTERN_INLINE)
+  if (C_EXTERN_INLINE)
+    set(HAVE_INLINE 1)
+  else ()
+    # Check for C99-style inline.
+    check_c_source_compiles("
+      extern inline void* foo() { foo(); return &foo; }
+      int main() { return foo() != 0; }" C_C99INLINE)
+    if (C_C99INLINE)
+      set(HAVE_INLINE 1)
+      set(HAVE_C99_INLINE 1)
+    endif ()
+  endif ()
+endif ()
+if (C_INLINE AND NOT C_HAS_inline)
+  set(inline ${C_INLINE})
+endif ()
+
+# Checks for header files.
+include(CheckIncludeFiles)
+foreach (header ieeefp.h dlfcn.h inttypes.h memory.h stdint.h stdlib.h
+                strings.h string.h sys/stat.h sys/types.h unistd.h)
+  string(TOUPPER HAVE_${header} var)
+  string(REGEX REPLACE "\\.|/" "_" var ${var})
+  check_include_files(${header} ${var})
+endforeach ()
+check_include_files(stdio.h STDC_HEADERS)
+
+# Check for IEEE arithmetic interface type.
+if (CMAKE_SYSTEM_NAME MATCHES Linux)
+  if (CMAKE_SYSTEM_PROCESSOR MATCHES sparc)
+    set(HAVE_GNUSPARC_IEEE_INTERFACE 1)
+  elseif (CMAKE_SYSTEM_PROCESSOR MATCHES powerpc)
+    set(HAVE_GNUPPC_IEEE_INTERFACE 1)
+  elseif (CMAKE_SYSTEM_PROCESSOR MATCHES 86)
+    set(HAVE_GNUX86_IEEE_INTERFACE 1)
+  endif ()
+elseif (CMAKE_SYSTEM_NAME MATCHES SunOS)
+  set(HAVE_SUNOS4_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES Solaris)
+  set(HAVE_SOLARIS_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES hpux)
+  set(HAVE_HPUX_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES Darwin)
+  if (CMAKE_SYSTEM_PROCESSOR MATCHES powerpc)
+    set(HAVE_DARWIN_IEEE_INTERFACE 1)
+  elseif (CMAKE_SYSTEM_PROCESSOR MATCHES 86)
+    set(HAVE_DARWIN86_IEEE_INTERFACE 1)
+  endif ()
+elseif (CMAKE_SYSTEM_NAME MATCHES NetBSD)
+  set(HAVE_NETBSD_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES OpenBSD)
+  set(HAVE_OPENBSD_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES FreeBSD)
+  set(HAVE_FREEBSD_IEEE_INTERFACE 1)
+endif ()
+
+# Check for FPU_SETCW.
+if (HAVE_GNUX86_IEEE_INTERFACE)
+  check_c_source_compiles("
+    #include <fpu_control.h>
+    #ifndef _FPU_SETCW
+    #include <i386/fpu_control.h>
+    #define _FPU_SETCW(cw) __setfpucw(cw)
+    #endif
+    int main() { unsigned short mode = 0 ; _FPU_SETCW(mode); }"
+    HAVE_FPU_SETCW)
+  if (NOT HAVE_FPU_SETCW)
+    set(HAVE_GNUX86_IEEE_INTERFACE 0)
+  endif ()
+endif ()
+
+# Check for SSE extensions.
+if (HAVE_GNUX86_IEEE_INTERFACE)
+  check_c_source_compiles("
+    #include <stdlib.h>
+    #define _FPU_SETMXCSR(cw) asm volatile (\"ldmxcsr %0\" : : \"m\" (*&cw))
+    int main() { unsigned int mode = 0x1f80 ; _FPU_SETMXCSR(mode); exit(0); }"
+    HAVE_FPU_X86_SSE)
+endif ()
+
+# Compiles the source code, runs the program and sets ${VAR} to 1 if the
+# return value is equal to ${RESULT}.
+macro(check_run_result SRC RESULT VAR)
+  set(SRC_FILE ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/src.c)
+  file(WRITE ${SRC_FILE} "${SRC}")
+  try_run(RUN_RESULT COMPILE_RESULT ${CMAKE_BINARY_DIR} ${SRC_FILE}
+          CMAKE_FLAGS -DLINK_LIBRARIES:STRING=${CMAKE_REQUIRED_LIBRARIES})
+  if (RUN_RESULT EQUAL ${RESULT})
+    set(${VAR} 1)
+  endif ()
+endmacro()
+
+# Check IEEE comparisons, whether "x != x" is true for NaNs.
+check_run_result("
+  #include <math.h>
+  int main (void)
+  {
+     int status; double inf, nan;
+     inf = exp(1.0e10);
+     nan = inf / inf ;
+     status = (nan == nan);
+     exit (status);
+  }" 0 HAVE_IEEE_COMPARISONS)
+
+# Check for IEEE denormalized arithmetic.
+check_run_result("
+  #include <math.h>
+  int main (void)
+  {
+     int i, status;
+     volatile double z = 1e-308;
+     for (i = 0; i < 5; i++) { z = z / 10.0 ; };
+     for (i = 0; i < 5; i++) { z = z * 10.0 ; };
+     status = (z == 0.0);
+     exit (status);
+  }" 0 HAVE_IEEE_DENORMALS)
+
+# Check for long double stdio.
+check_run_result("
+  #include <stdlib.h>
+  #include <stdio.h>
+  int main (void)
+  {
+    const char * s = \"5678.25\"; long double x = 1.234 ;
+    fprintf(stderr,\"%Lg\n\",x) ;
+    sscanf(s, \"%Lg\", &x);
+    if (x == 5678.25) {exit (0);} else {exit(1); }
+  }" 0 HAVE_PRINTF_LONGDOUBLE)
+
+if (NOT CMAKE_COMPILER_IS_GNUCC)
+  check_run_result("
+    #include <limits.h>
+    int main (void) { return CHAR_MIN == 0; }" 1 __CHAR_UNSIGNED__)
+endif ()
+
+# Remember to put a definition in config.h.in for each of these.
+include(CheckSymbolExists)
+check_symbol_exists(EXIT_SUCCESS stdlib.h HAVE_EXIT_SUCCESS)
+check_symbol_exists(EXIT_FAILURE stdlib.h HAVE_EXIT_FAILURE)
+if (HAVE_EXIT_SUCCESS AND HAVE_EXIT_FAILURE)
+  set(HAVE_EXIT_SUCCESS_AND_FAILURE 1)
+endif ()
+set(CMAKE_REQUIRED_DEFINITIONS "-D_GNU_SOURCE=1")
+check_symbol_exists(feenableexcept fenv.h HAVE_DECL_FEENABLEEXCEPT)
+check_symbol_exists(fesettrapenable fenv.h HAVE_DECL_FESETTRAPENABLE)
+set(CMAKE_REQUIRED_DEFINITIONS "")
+check_symbol_exists(hypot math.h HAVE_DECL_HYPOT)
+check_symbol_exists(expm1 math.h HAVE_DECL_EXPM1)
+check_symbol_exists(acosh math.h HAVE_DECL_ACOSH)
+check_symbol_exists(asinh math.h HAVE_DECL_ASINH)
+check_symbol_exists(atanh math.h HAVE_DECL_ATANH)
+check_symbol_exists(ldexp math.h HAVE_DECL_LDEXP)
+check_symbol_exists(frexp math.h HAVE_DECL_FREXP)
+check_symbol_exists(fprnd_t float.h HAVE_DECL_FPRND_T)
+check_symbol_exists(isinf math.h HAVE_DECL_ISINF)
+check_symbol_exists(isfinite math.h HAVE_DECL_ISFINITE)
+if (HAVE_IEEEFP_H)
+  set(IEEEFP_H ieeefp.h)
+endif ()
+check_symbol_exists(finite math.h;${IEEEFP_H} HAVE_DECL_FINITE)
+check_symbol_exists(isnan math.h HAVE_DECL_ISNAN)
+
+# OpenBSD has a broken implementation of log1p.
+if (CMAKE_SYSTEM_NAME MATCHES OpenBSD)
+  message("avoiding OpenBSD system log1p - using gsl version")
+else ()
+  check_symbol_exists(log1p math.h HAVE_DECL_LOG1P)
+endif ()
+
+# Check for extended floating point registers.
+if (NOT (CMAKE_SYSTEM_PROCESSOR MATCHES "^(sparc|powerpc|hppa|alpha)"))
+  set(HAVE_EXTENDED_PRECISION_REGISTERS 1)
+endif ()
+
+check_symbol_exists(memcpy string.h HAVE_MEMCPY)
+check_symbol_exists(memmove string.h HAVE_MEMMOVE)
+check_symbol_exists(strdup string.h HAVE_STRDUP)
+check_symbol_exists(strtol stdlib.h HAVE_STRTOL)
+check_symbol_exists(strtoul stdlib.h HAVE_STRTOUL)
+check_symbol_exists(vprintf stdio.h HAVE_VPRINTF)
+
+# Process config.h using autoconf rules.
+#file(STRINGS ${GSL_SOURCE_DIR}/config.h.in CONFIG)
+list(LENGTH CONFIG length)
+math(EXPR length "${length} - 1")
+foreach (i RANGE ${length})
+  list(GET CONFIG ${i} line)
+  if (line MATCHES "^#( *)undef (.*)\n")
+    set(space "${CMAKE_MATCH_1}")
+    set(var ${CMAKE_MATCH_2})
+    if (NOT DEFINED ${var} OR (var MATCHES "HAVE_.*_H" AND NOT ${var}))
+      set(line "/* #${space}undef ${var} */\n")
+    else ()
+      if ("${${var}}" STREQUAL "/**/" OR "${var}" STREQUAL "inline")
+        set(value ${${var}})
+      elseif (NOT (var MATCHES ^HAVE OR ${var} EQUAL 0 OR ${var} EQUAL 1))
+        set(value \"${${var}}\")
+      elseif (${var})
+        set(value 1)
+      else ()
+        set(value 0)
+      endif ()
+      set(line "#${space}define ${var} ${value}\n")
+    endif ()
+  elseif (BUILD_SHARED_LIBS AND WIN32 AND line MATCHES "^#define GSL_DISABLE_DEPRECATED .*")
+    # Keep deprecated symbols when compiling a Windows DLL to prevent linkage errors.
+    set(line "/* #undef GSL_DISABLE_DEPRECATED */\n")
+  endif ()
+  string(REPLACE "<semi>" ";" line "${line}")
+  set(CONFIG_OUT "${CONFIG_OUT}${line}")
+endforeach ()
+file(WRITE ${GSL_BINARY_DIR}/config.h
+"/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+${CONFIG_OUT}")
+
+include_directories(${GSL_BINARY_DIR} ${GSL_SOURCE_DIR})
+add_definitions(-DHAVE_CONFIG_H)
+
+if (GSL_DISABLE_WARNINGS)
+  # Disable additional warnings.
+  if (MSVC)
+    add_definitions(
+      -D_CRT_SECURE_NO_WARNINGS
+      /wd4018 /wd4028 /wd4056 /wd4244 /wd4267 /wd4334 /wd4700 /wd4723 /wd4756)
+  else ()
+    foreach (flag -Wall -Wextra -pedantic)
+      string(REPLACE ${flag} "" CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
+    endforeach ()
+  endif ()
+endif ()
+
+option(MSVC_RUNTIME_DYNAMIC "Use dynamically-linked runtime: /MD(d)" OFF)
+
+if (MSVC_RUNTIME_DYNAMIC)
+  set(CMAKE_COMPILER_FLAGS_VARIABLES
+    CMAKE_C_FLAGS_DEBUG
+    CMAKE_C_FLAGS_MINSIZEREL
+    CMAKE_C_FLAGS_RELEASE
+    CMAKE_C_FLAGS_RELWITHDEBINFO
+    CMAKE_CXX_FLAGS_DEBUG
+    CMAKE_CXX_FLAGS_MINSIZEREL
+    CMAKE_CXX_FLAGS_RELEASE
+    CMAKE_CXX_FLAGS_RELWITHDEBINFO
+  )
+  foreach(variable ${CMAKE_COMPILER_FLAGS_VARIABLES})
+    string(REGEX REPLACE "/MT" "/MD" ${variable} "${${variable}}")
+  endforeach()
+endif ()
+
+enable_testing()
+
+# Adds a GSL test. Usage:
+#   add_gsl_test(<exename> <source> ...)
+function(add_gsl_test exename)
+  if (GSL_DISABLE_TESTS)
+    return()
+  endif ()
+  add_executable(${exename} ${ARGN})
+  target_link_libraries(${exename} gsl)
+  add_test(${exename} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${exename})
+endfunction()
+
+file(GLOB GSL_HEADER_PATHS "${GSL_SOURCE_DIR}/gsl*.h")
+file(GLOB dirs "${GSL_SOURCE_DIR}/*")
+foreach (dir ${dirs})
+  if (NOT (dir MATCHES "gsl$"))
+    file(GLOB headers "${dir}/gsl*.h")
+    set(GSL_HEADER_PATHS ${GSL_HEADER_PATHS} ${headers})
+  endif ()
+endforeach()
+
+foreach (path ${GSL_HEADER_PATHS})
+  get_filename_component(name ${path} NAME)
+  set(GSL_HEADERS ${GSL_HEADERS} gsl/${name})
+endforeach ()
+
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/copy-headers.cmake "
+  file(MAKE_DIRECTORY gsl)
+  foreach (path ${GSL_HEADER_PATHS})
+    get_filename_component(filename \${path} NAME)
+    configure_file(\${path} ${GSL_BINARY_DIR}/gsl/\${filename} COPYONLY)
+  endforeach ()")
+
+add_custom_command(OUTPUT ${GSL_HEADERS}
+  COMMAND ${CMAKE_COMMAND} -P copy-headers.cmake)
+add_custom_target(copy-headers DEPENDS ${GSL_HEADERS})
+
+macro(get_sources dir line source_var)
+  set(${source_var})
+  string(REGEX REPLACE ".*_SOURCES[ \t]*=(.*)" "\\1" sources ${line})
+  string(REGEX MATCHALL "[^ \t]+" sources ${sources})
+  foreach (src ${sources})
+    set(${source_var} ${${source_var}} ${dir}/${src})
+  endforeach ()
+endmacro()
+
+# Get subdirectories from Makefile.am.
+file(STRINGS Makefile.am lines REGEX "^SUBDIRS[ \t]*=")
+foreach (line ${lines})
+  string(REGEX REPLACE "SUBDIRS[ \t]*=(.*)" "\\1" dirs ${line})
+  string(REGEX MATCHALL "[^ ]+" dirs ${dirs})
+endforeach ()
+
+# Extract sources from automake files and add tests.
+foreach (dir "." ${dirs})
+  file(STRINGS ${dir}/Makefile.am lines)
+  foreach (line ${lines})
+    if (line MATCHES "_la_SOURCES[ \t]*=")
+      get_sources(${dir} "${line}" SOURCES)
+      if (dir STREQUAL cblas)
+        # Build gslcblas as a static library on MSVC because it doesn't have a .def file.
+        if (MSVC)
+          set(GSLCBLAS_TYPE STATIC)
+        endif ()
+        add_library(gslcblas ${GSLCBLAS_TYPE} ${SOURCES})
+        target_link_libraries(gslcblas ${CMAKE_REQUIRED_LIBRARIES})
+        add_dependencies(gslcblas copy-headers)
+      else ()
+        set(GSL_SOURCES ${GSL_SOURCES} ${SOURCES})
+      endif ()
+    elseif (line MATCHES "^test.*_SOURCES[ \t]*=")
+      get_sources(${dir} "${line}" SOURCES)
+      string(REGEX REPLACE "(.*)_SOURCES.*" "\\1" suffix ${line})
+      add_gsl_test("${dir}_${suffix}" ${SOURCES})
+    endif ()
+  endforeach ()
+endforeach ()
+
+if (BUILD_SHARED_LIBS)
+  include(CheckCCompilerFlag)
+  check_c_compiler_flag(-fPIC HAVE_FPIC)
+  if (HAVE_FPIC)
+    add_definitions(-fPIC)
+  endif ()
+  if (WIN32)
+    add_definitions(-DGSL_DLL)
+    # Extract function names from header and generate a .def file.
+    file(WRITE gsl.def "LIBRARY GSL\nEXPORTS\n")
+    foreach (header ${GSL_HEADER_PATHS})
+      file(READ ${header} content)
+      string(REGEX REPLACE
+        "/\\*([^*]|[\r\n]|(\\*+([^*/]|[\r\n])))*\\*+/" " " content "${content}")
+      set(RE "\n([^\n]*[ *])?(gsl_[A-Za-z0-9_]+)[ ]*\\(")
+      string(REGEX MATCHALL "${RE}" candidates "${content}")
+      foreach (line ${candidates})
+        if (NOT line MATCHES typedef AND line MATCHES "${RE}")
+          file(APPEND gsl.def "   ${CMAKE_MATCH_2}\n")
+        endif ()
+      endforeach ()
+    endforeach ()
+    set(GSL_SOURCES ${GSL_SOURCES} gsl.def)
+  endif ()
+endif ()
+
+add_library(gsl ${shared} ${GSL_SOURCES})
+set_target_properties(gsl PROPERTIES COMPILE_DEFINITIONS DLL_EXPORT)
+target_link_libraries(gsl gslcblas)
+add_dependencies(gsl copy-headers)
+
+option(GSL_INSTALL_MULTI_CONFIG "Install libraries in lib/<config> directory" OFF)
+
+if (GSL_INSTALL OR NOT DEFINED GSL_INSTALL)
+  if (MSVC AND GSL_INSTALL_MULTI_CONFIG)
+    foreach(config ${CMAKE_CONFIGURATION_TYPES})
+      install(TARGETS gsl gslcblas
+        CONFIGURATIONS ${config}
+        LIBRARY DESTINATION lib/${config}
+        RUNTIME DESTINATION bin/${config}
+        ARCHIVE DESTINATION lib/${config})
+    endforeach ()
+    install(FILES ${PROJECT_BINARY_DIR}/Debug/gsl.pdb
+                  ${PROJECT_BINARY_DIR}/Debug/gslcblas.pdb
+          DESTINATION lib/Debug
+          CONFIGURATIONS Debug)
+  else ()
+    install(TARGETS gsl gslcblas
+      LIBRARY DESTINATION lib
+      RUNTIME DESTINATION bin
+      ARCHIVE DESTINATION lib)
+    if (MSVC)
+      install(FILES ${PROJECT_BINARY_DIR}/Debug/gsl.pdb
+                    ${PROJECT_BINARY_DIR}/Debug/gslcblas.pdb
+            DESTINATION lib
+            CONFIGURATIONS Debug)
+    endif ()
+  endif ()
+  install(FILES ${GSL_HEADER_PATHS} DESTINATION include/gsl)
+  set(PC_FILE ${CMAKE_BINARY_DIR}/gsl.pc)
+  configure_file("gsl.pc.cmake" ${PC_FILE} @ONLY)
+  install(FILES ${PC_FILE} DESTINATION lib/pkgconfig)
+endif ()
diff --git a/appveyor.yml b/appveyor.yml
new file mode 100644
index 0000000..979ab56
--- /dev/null
+++ b/appveyor.yml
@@ -0,0 +1,8 @@
+install: set PATH=C:\Program Files (x86)\MSBuild\14.0\Bin;%PATH%
+
+before_build:
+  - cmake .
+
+build_script:
+  - msbuild /m GSL.sln
+  - msbuild RUN_TESTS.vcxproj
diff --git a/cmake/c_flag_overrides.cmake b/cmake/c_flag_overrides.cmake
new file mode 100644
index 0000000..e72f341
--- /dev/null
+++ b/cmake/c_flag_overrides.cmake
@@ -0,0 +1,6 @@
+if (MSVC)
+  set(CMAKE_C_FLAGS_DEBUG_INIT          "/MP /D_DEBUG /MTd /Zi /Ob0 /Od /RTC1")
+  set(CMAKE_C_FLAGS_MINSIZEREL_INIT     "/MP /MT /O1 /Ob1 /D NDEBUG")
+  set(CMAKE_C_FLAGS_RELEASE_INIT        "/MP /MT /O2 /Ob2 /D NDEBUG")
+  set(CMAKE_C_FLAGS_RELWITHDEBINFO_INIT "/MP /MT /Zi /O2 /Ob1 /D NDEBUG")
+endif ()
diff --git a/cmake/cxx_flag_overrides.cmake b/cmake/cxx_flag_overrides.cmake
new file mode 100644
index 0000000..9d83af5
--- /dev/null
+++ b/cmake/cxx_flag_overrides.cmake
@@ -0,0 +1,6 @@
+if (MSVC)
+  set(CMAKE_CXX_FLAGS_DEBUG_INIT          "/MP /D_DEBUG /MTd /Zi /Ob0 /Od /RTC1")
+  set(CMAKE_CXX_FLAGS_MINSIZEREL_INIT     "/MP /MT /O1 /Ob1 /D NDEBUG")
+  set(CMAKE_CXX_FLAGS_RELEASE_INIT        "/MP /MT /O2 /Ob2 /D NDEBUG")
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO_INIT "/MP /MT /Zi /O2 /Ob1 /D NDEBUG")
+endif ()
diff --git a/cmake/init.cmake b/cmake/init.cmake
new file mode 100644
index 0000000..df402ae
--- /dev/null
+++ b/cmake/init.cmake
@@ -0,0 +1,92 @@
+# CMake initialization code that should be run before the project command.
+
+include(CMakeParseArguments)
+
+# Joins arguments and sets the result to <var>.
+# Usage:
+#   join(<var> [<arg>...])
+function (join var)
+  unset(result)
+  foreach (arg ${ARGN})
+    if (DEFINED result)
+      set(result "${result} ${arg}")
+    else ()
+      set(result "${arg}")
+    endif ()
+  endforeach ()
+  set(${var} "${result}" PARENT_SCOPE)
+endfunction ()
+
+# Sets cache variable <var> to the value <value>. The arguments
+# following <type> are joined into a single docstring which allows
+# breaking long documentation into smaller strings.
+# Usage:
+#   set_cache(<var> <value> <type> docstring... [FORCE])
+function (set_cache var value type)
+  cmake_parse_arguments(set_cache FORCE "" "" ${ARGN})
+  unset(force)
+  if (set_cache_FORCE)
+    set(force FORCE)
+  endif ()
+  join(docstring ${set_cache_UNPARSED_ARGUMENTS})
+  set(${var} ${value} CACHE ${type} "${docstring}" ${force})
+endfunction ()
+
+if (NOT CMAKE_BUILD_TYPE)
+  # Set the default CMAKE_BUILD_TYPE to Release.
+  # This should be done before the project command since the latter sets
+  # CMAKE_BUILD_TYPE itself.
+  set_cache(CMAKE_BUILD_TYPE Release STRING
+    "Choose the type of build, options are: None(CMAKE_CXX_FLAGS or"
+    "CMAKE_C_FLAGS used) Debug Release RelWithDebInfo MinSizeRel.")
+endif ()
+
+function (override var file)
+  if (EXISTS "${file}")
+    set(${var} ${file} PARENT_SCOPE)
+  endif ()
+endfunction ()
+
+# Set compiler options (MSVC)
+# This should be done before the project command.
+override(CMAKE_USER_MAKE_RULES_OVERRIDE
+  ${CMAKE_CURRENT_LIST_DIR}/c_flag_overrides.cmake)
+override(CMAKE_USER_MAKE_RULES_OVERRIDE_CXX
+  ${CMAKE_CURRENT_LIST_DIR}/cxx_flag_overrides.cmake)
+
+if (MP_WINSDK)
+  # Find Windows SDK.
+  set(winsdk_key
+    "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows")
+  find_program(MP_SETENV NAMES SetEnv.cmd
+    PATHS "[${winsdk_key};CurrentInstallFolder]/bin")
+  if (MP_SETENV)
+    if (NOT CMAKE_GENERATOR MATCHES Win64)
+      set(setenv_arg "/x86")
+    endif ()
+
+    # Call SetEnv.cmd and set environment variables accordingly.
+    message(STATUS "Found SetEnv: ${MP_SETENV}")
+    set(run_setenv "CMakeFiles\\run-setenv.bat")
+    file(WRITE ${run_setenv} "call %*\nset\n")
+    execute_process(COMMAND ${run_setenv} "${MP_SETENV}" "${setenv_arg}"
+      OUTPUT_VARIABLE out ERROR_VARIABLE err)
+    string(REPLACE ";" "\;" out "${out}")
+    string(REGEX MATCHALL "[^\n]+\n" out "${out}")
+    foreach (env ${out})
+      if (env MATCHES "([^=]+)=(.*)\n")
+        set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
+      endif ()
+    endforeach ()
+
+    # If Microsoft SDK is installed create script run-msbuild.bat that
+    # calls SetEnv.cmd to set up build environment and runs msbuild.
+    # It is useful when building Visual Studio projects with the SDK
+    # toolchain rather than Visual Studio.
+    # Set FrameworkPathOverride to get rid of MSB3644 warnings.
+    file(WRITE "${CMAKE_BINARY_DIR}/run-msbuild.bat" "
+      call \"${MP_SETENV}\" ${setenv_arg}
+      msbuild -p:FrameworkPathOverride=^\"C:\\Program Files^
+\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0^\" %*")
+  endif ()
+endif ()
diff --git a/doc/examples/expfit.c b/doc/examples/expfit.c
new file mode 100644
index 0000000..328177a
--- /dev/null
+++ b/doc/examples/expfit.c
@@ -0,0 +1,56 @@
+/* expfit.c -- model functions for exponential + background */
+
+struct data {
+  size_t n;
+  double * y;
+};
+
+int
+expb_f (const gsl_vector * x, void *data, 
+        gsl_vector * f)
+{
+  size_t n = ((struct data *)data)->n;
+  double *y = ((struct data *)data)->y;
+
+  double A = gsl_vector_get (x, 0);
+  double lambda = gsl_vector_get (x, 1);
+  double b = gsl_vector_get (x, 2);
+
+  size_t i;
+
+  for (i = 0; i < n; i++)
+    {
+      /* Model Yi = A * exp(-lambda * i) + b */
+      double t = i;
+      double Yi = A * exp (-lambda * t) + b;
+      gsl_vector_set (f, i, Yi - y[i]);
+    }
+
+  return GSL_SUCCESS;
+}
+
+int
+expb_df (const gsl_vector * x, void *data, 
+         gsl_matrix * J)
+{
+  size_t n = ((struct data *)data)->n;
+
+  double A = gsl_vector_get (x, 0);
+  double lambda = gsl_vector_get (x, 1);
+
+  size_t i;
+
+  for (i = 0; i < n; i++)
+    {
+      /* Jacobian matrix J(i,j) = dfi / dxj, */
+      /* where fi = (Yi - yi)/sigma[i],      */
+      /*       Yi = A * exp(-lambda * i) + b  */
+      /* and the xj are the parameters (A,lambda,b) */
+      double t = i;
+      double e = exp(-lambda * t);
+      gsl_matrix_set (J, i, 0, e); 
+      gsl_matrix_set (J, i, 1, -t * A * e);
+      gsl_matrix_set (J, i, 2, 1.0);
+    }
+  return GSL_SUCCESS;
+}
diff --git a/doc/multifit.texi b/doc/multifit.texi
new file mode 100644
index 0000000..318eddc
--- /dev/null
+++ b/doc/multifit.texi
@@ -0,0 +1,1170 @@
+@cindex nonlinear least squares fitting
+@cindex least squares fitting, nonlinear
+
+This chapter describes functions for multidimensional nonlinear
+least-squares fitting.  The library provides low level components for a
+variety of iterative solvers and convergence tests.  These can be
+combined by the user to achieve the desired solution, with full access
+to the intermediate steps of the iteration.  Each class of methods uses
+the same framework, so that you can switch between solvers at runtime
+without needing to recompile your program.  Each instance of a solver
+keeps track of its own state, allowing the solvers to be used in
+multi-threaded programs.
+
+The header file @file{gsl_multifit_nlin.h} contains prototypes for the
+multidimensional nonlinear fitting functions and related declarations.
+
+@menu
+* Overview of Nonlinear Least-Squares Fitting::  
+* Overview of Weighted Nonlinear Least-Squares Fitting::  
+* Overview of Regularized Nonlinear Least-Squares Fitting::  
+* Initializing the Nonlinear Least-Squares Solver::  
+* Providing the Function to be Minimized::  
+* Finite Difference Jacobian::  
+* Iteration of the Minimization Algorithm::  
+* Search Stopping Parameters for Minimization Algorithms::  
+* High Level Driver::
+* Minimization Algorithms using Derivatives::  
+* Minimization Algorithms without Derivatives::  
+* Computing the covariance matrix of best fit parameters::  
+* Troubleshooting Nonlinear Least Squares::
+* Example programs for Nonlinear Least-Squares Fitting::  
+* References and Further Reading for Nonlinear Least-Squares Fitting::  
+@end menu
+
+@node Overview of Nonlinear Least-Squares Fitting
+@section Overview
+@cindex nonlinear least squares fitting, overview
+
+The problem of multidimensional nonlinear least-squares fitting requires
+the minimization of the squared residuals of @math{n} functions,
+@math{f_i}, in @math{p} parameters, @math{x_i},
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} || f(x) ||^2
+         = {1 \over 2} \sum_{i=1}^{n} f_i (x_1, \dots, x_p)^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f(x) ||^2
+        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
+@end example
+
+@end ifinfo
+@noindent
+All algorithms proceed from an initial guess using the linearization,
+@tex
+\beforedisplay
+$$
+\psi(\delta) = || f(x+\delta) || \approx || f(x) + J \delta\, ||
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\psi(\delta) = || f(x+\delta) || ~=~ || f(x) + J \delta ||
+@end example
+
+@end ifinfo
+@noindent
+where @math{x} is the initial point, @math{\delta} is the proposed step
+and @math{J} is the
+Jacobian matrix @c{$J_{ij} = \partial f_i / \partial x_j$}
+@math{J_@{ij@} = d f_i / d x_j}.  
+Additional strategies are used to enlarge the region of convergence.
+These include requiring a decrease in the norm @math{||f||} on each
+step or using a trust region to avoid steps which fall outside the linear 
+regime.
+
+@noindent
+Note that the model parameters are denoted by @math{x} in this chapter
+since the non-linear least-squares algorithms are described
+geometrically (i.e. finding the minimum of a surface).  The
+independent variable of any data to be fitted is denoted by @math{t}.
+
+@node Overview of Weighted Nonlinear Least-Squares Fitting
+@section Weighted Nonlinear Least-Squares
+
+Weighted nonlinear least-squares fitting minimizes the function
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} f^T W f
+         = {1 \over 2} \sum_{i=1}^{n} w_i f_i (x_1, \dots, x_p)^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f(x) ||^2
+        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
+@end example
+
+@end ifinfo
+where @math{W = diag(w_1,w_2,...,w_n)} is the weighting matrix,
+and the weights @math{w_i} are commonly defined as @math{w_i = 1/\sigma_i^2},
+where @math{\sigma_i} is the error in the @math{i}th measurement.
+A simple change of variables @math{\tilde{f} = \sqrt{W} f} yields
+@math{\Phi(x) = {1 \over 2} ||\tilde{f}||^2}, which is in the
+same form as the unweighted case. The user can either perform this
+transform directly on their function residuals and Jacobian, or use
+the @code{gsl_multifit_fdfsolver_wset} interface which automatically
+performs the correct scaling. To manually perform this transformation,
+the residuals and Jacobian should be modified according to
+@tex
+\beforedisplay
+$$
+\eqalign{
+f_i & = \sqrt{w_i} (Y_i - y_i) = {(Y_i - y_i) \over \sigma_i} \cr
+J_{ij} & = \sqrt{w_i} { \partial Y_i \over \partial x_j } = { 1 \over \sigma_i} { \partial Y_i \over \partial x_j }
+}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f_i = (Y(x, t_i) - y_i) / \sigma_i
+@end example
+
+@end ifinfo
+where @math{Y_i = Y(x,t_i)}.
+
+@node Overview of Regularized Nonlinear Least-Squares Fitting
+@section Regularized Nonlinear Least-Squares
+In cases where the Jacobian @math{J} is rank-deficient or singular,
+standard nonlinear least squares can sometimes produce
+undesirable and unstable solutions. In these cases, it can
+help to regularize the problem using ridge or Tikhonov regularization.
+In this method, we introduce a term in our minimization function
+which is designed to damp the solution vector @math{x}, or give preference
+to solutions with smaller norms.
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} || f(x) ||^2 + {1 \over 2} || L x ||^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f(x) ||^2 + (1/2) ||Lx||^2
+@end example
+
+@end ifinfo
+Here, the regularization matrix @math{L} is often set
+as @math{L = \lambda I}, for a positive scalar @math{\lambda}, but can
+also be a general @math{m}-by-@math{p} (where @math{m} is any number
+of rows) matrix depending on the
+structure of the problem to be solved. If we define a new
+@math{(n+m)}-by-1 vector
+@tex
+\beforedisplay
+$$
+\tilde{f}(x) =
+\left[
+\matrix{
+f(x) \cr
+L x
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f~(x) = [ f(x); Lx ]
+@end example
+
+@end ifinfo
+or, in the weighted case,
+@tex
+\beforedisplay
+$$
+\tilde{f}(x) =
+\left[
+\matrix{
+\sqrt{W} f(x) \cr
+L x
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f~(x) = [ sqrt(W) f(x); Lx ]
+@end example
+
+@end ifinfo
+then
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} || \tilde{f}(x) ||^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f~(x) ||^2
+@end example
+
+@end ifinfo
+which is in the same form as the standard nonlinear least squares
+problem. The corresponding @math{(n+m)}-by-@math{p} Jacobian matrix is
+@tex
+\beforedisplay
+$$
+\tilde{J} =
+\left[
+\matrix{
+J \cr
+L
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+F~(x) = [ J; L ]
+@end example
+
+@end ifinfo
+or for weighted systems
+@tex
+\beforedisplay
+$$
+\tilde{J} =
+\left[
+\matrix{
+\sqrt{W} J \cr
+L
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+F~(x) = [ sqrt(W) J; L ]
+@end example
+
+@end ifinfo
+While the user could explicitly form the @math{\tilde{f}(x)} vector
+and @math{\tilde{J}} matrix, the @code{fdfridge} interface
+described below allows the user to specify the original data vector
+@math{f(x)}, Jacobian @math{J}, regularization matrix
+@math{L}, and optional weighting matrix @math{W}, and automatically
+forms @math{\tilde{f}(x)} and
+@math{\tilde{J}} to solve the system. This allows switching
+between regularized and non-regularized solutions with minimal
+code changes.
+
+@node Initializing the Nonlinear Least-Squares Solver
+@section Initializing the Solver
+
+@deftypefun {gsl_multifit_fsolver *} gsl_multifit_fsolver_alloc (const gsl_multifit_fsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
+@tindex gsl_multifit_fsolver
+@tindex gsl_multifit_fsolver_type
+This function returns a pointer to a newly allocated instance of a
+solver of type @var{T} for @var{n} observations and @var{p} parameters.
+The number of observations @var{n} must be greater than or equal to
+parameters @var{p}. 
+
+If there is insufficient memory to create the solver then the function
+returns a null pointer and the error handler is invoked with an error
+code of @code{GSL_ENOMEM}.
+@end deftypefun
+
+@deftypefun {gsl_multifit_fdfsolver *} gsl_multifit_fdfsolver_alloc (const gsl_multifit_fdfsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
+@tindex gsl_multifit_fdfsolver
+@tindex gsl_multifit_fdfsolver_type
+This function returns a pointer to a newly allocated instance of a
+derivative solver of type @var{T} for @var{n} observations and @var{p}
+parameters.  For example, the following code creates an instance of a
+Levenberg-Marquardt solver for 100 data points and 3 parameters,
+
+@example
+const gsl_multifit_fdfsolver_type * T 
+    = gsl_multifit_fdfsolver_lmder;
+gsl_multifit_fdfsolver * s 
+    = gsl_multifit_fdfsolver_alloc (T, 100, 3);
+@end example
+
+@noindent
+The number of observations @var{n} must be greater than or equal to
+parameters @var{p}.
+
+If there is insufficient memory to create the solver then the function
+returns a null pointer and the error handler is invoked with an error
+code of @code{GSL_ENOMEM}.
+@end deftypefun
+
+@deftypefun {gsl_multifit_fdfridge *} gsl_multifit_fdfridge_alloc (const gsl_multifit_fdfsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
+@tindex gsl_multifit_fdfridge
+This function returns a pointer to a newly allocated instance of a
+derivative solver of type @var{T} for @var{n} observations and @var{p}
+parameters. The solver will automatically form the augmented
+system @math{\tilde{f}(x)} and @math{\tilde{J}} for ridge (Tikhonov)
+regression.
+If there is insufficient memory to create the solver then the function
+returns a null pointer and the error handler is invoked with an error
+code of @code{GSL_ENOMEM}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fsolver_set (gsl_multifit_fsolver * @var{s}, gsl_multifit_function * @var{f}, const gsl_vector * @var{x})
+This function initializes, or reinitializes, an existing solver @var{s}
+to use the function @var{f} and the initial guess @var{x}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x})
+@deftypefunx int gsl_multifit_fdfsolver_wset (gsl_multifit_fdfsolver * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{wts})
+These functions initialize, or reinitialize, an existing solver @var{s}
+to use the function and derivative @var{fdf} and the initial guess
+@var{x}.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfridge_set (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const double @var{lambda})
+@deftypefunx int gsl_multifit_fdfridge_wset (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const double @var{lambda}, const gsl_vector * @var{wts})
+This function initializes, or reinitializes, an existing ridge solver
+@var{s} to use the function and derivative @var{fdf} and the initial guess
+@var{x}. Here, the regularization matrix is set to @math{L = \lambda I},
+with @math{\lambda} specified in @var{lambda}.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfridge_set2 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{lambda})
+@deftypefunx int gsl_multifit_fdfridge_wset2 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{lambda}, const gsl_vector * @var{wts})
+This function initializes, or reinitializes, an existing ridge solver
+@var{s} to use the function and derivative @var{fdf} and the initial
+guess @var{x}. Here, the regularization matrix is set to
+@math{L = diag(\lambda_1,\lambda_2,...,\lambda_p)}, where
+the @math{\lambda_i} are given in @var{lambda}.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfridge_set3 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_matrix * @var{L})
+@deftypefunx int gsl_multifit_fdfridge_wset3 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_matrix * @var{L}, const gsl_vector * @var{wts})
+This function initializes, or reinitializes, an existing ridge solver
+@var{s} to use the function and derivative @var{fdf} and the initial
+guess @var{x}. Here, the regularization matrix is set to @var{L},
+which must have @math{p} columns but may have any number of rows.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun void gsl_multifit_fsolver_free (gsl_multifit_fsolver * @var{s})
+@deftypefunx void gsl_multifit_fdfsolver_free (gsl_multifit_fdfsolver * @var{s})
+@deftypefunx void gsl_multifit_fdfridge_free (gsl_multifit_fdfridge * @var{s})
+These functions free all the memory associated with the solver @var{s}.
+@end deftypefun
+
+@deftypefun {const char *} gsl_multifit_fsolver_name (const gsl_multifit_fsolver * @var{s})
+@deftypefunx {const char *} gsl_multifit_fdfsolver_name (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx {const char *} gsl_multifit_fdfridge_name (const gsl_multifit_fdfridge * @var{s})
+These functions return a pointer to the name of the solver.  For example,
+
+@example
+printf ("s is a '%s' solver\n", 
+        gsl_multifit_fdfsolver_name (s));
+@end example
+
+@noindent
+would print something like @code{s is a 'lmder' solver}.
+@end deftypefun
+
+@node Providing the Function to be Minimized
+@section Providing the Function to be Minimized
+
+You must provide @math{n} functions of @math{p} variables for the
+minimization algorithms to operate on.  In order to allow for
+arbitrary parameters the functions are defined by the following data
+types:
+
+@deftp {Data Type} gsl_multifit_function 
+This data type defines a general system of functions with arbitrary parameters.  
+
+@table @code
+@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
+this function should store the vector result
+@c{$f(x,\hbox{\it params})$}
+@math{f(x,params)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
+returning an appropriate error code if the function cannot be computed.
+
+@item size_t n
+the number of functions, i.e. the number of components of the
+vector @var{f}.
+
+@item size_t p
+the number of independent variables, i.e. the number of components of
+the vector @var{x}.
+
+@item void * params
+a pointer to the arbitrary parameters of the function.
+@end table
+@end deftp
+
+@deftp {Data Type} gsl_multifit_function_fdf
+This data type defines a general system of functions with arbitrary parameters and
+the corresponding Jacobian matrix of derivatives,
+
+@table @code
+@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
+this function should store the vector result
+@c{$f(x,\hbox{\it params})$}
+@math{f(x,params)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
+returning an appropriate error code if the function cannot be computed.
+
+@item int (* df) (const gsl_vector * @var{x}, void * @var{params}, gsl_matrix * @var{J})
+this function should store the @var{n}-by-@var{p} matrix result
+@c{$J_{ij} = \partial f_i(x,\hbox{\it params}) / \partial x_j$}
+@math{J_ij = d f_i(x,params) / d x_j} in @var{J} for argument @var{x} 
+and arbitrary parameters @var{params}, returning an appropriate error code if the
+function cannot be computed. If an analytic Jacobian is unavailable, or too expensive
+to compute, this function pointer may be set to NULL, in which
+case the Jacobian will be internally computed using finite difference approximations
+of the function @var{f}.
+
+@item size_t n
+the number of functions, i.e. the number of components of the
+vector @var{f}.
+
+@item size_t p
+the number of independent variables, i.e. the number of components of
+the vector @var{x}.
+
+@item void * params
+a pointer to the arbitrary parameters of the function.
+
+@item size_t nevalf
+This does not need to be set by the user. It counts the number of
+function evaluations and is initialized by the @code{_set} function.
+
+@item size_t nevaldf
+This does not need to be set by the user. It counts the number of
+Jacobian evaluations and is initialized by the @code{_set} function.
+@end table
+@end deftp
+
+Note that when fitting a non-linear model against experimental data,
+the data is passed to the functions above using the
+@var{params} argument and the trial best-fit parameters through the
+@var{x} argument.
+
+@node Finite Difference Jacobian
+@section Finite Difference Jacobian
+
+For the algorithms which require a Jacobian matrix of derivatives of
+the fit functions, there are times when an analytic Jacobian may be
+unavailable or too expensive to compute. Therefore GSL supports
+approximating the Jacobian numerically using finite differences of the fit
+functions. This is typically done by setting the relevant function pointers
+of the @code{gsl_multifit_function_fdf} data type to NULL, however the
+following functions allow the user to access the approximate Jacobian
+directly if needed.
+
+@deftypefun int gsl_multifit_fdfsolver_dif_df (const gsl_vector * @var{x}, const gsl_vector * @var{wts}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{f}, gsl_matrix * @var{J})
+This function takes as input the current position @var{x}, weight
+vector @var{wts} and function values computed at the current position
+@var{f}, along with @var{fdf} which specifies the fit function and
+parameters and approximates the
+@var{n}-by-@var{p} Jacobian @var{J} using forward finite differences:
+@c{$J_{ij} = \sqrt{w_i} \partial f_i(x) / \partial x_j \approx \sqrt{w_i} (f_i(x + h_j e_j) - f_i(x)) / h_j$}
+@math{J_ij = sqrt(w_i) d f_i(x) / d x_j = sqrt(w_i) (f_i(x + h_j e_j) - f_i(x)) / h_j}.
+where @math{h_j = \epsilon |x_j|}, and @math{\epsilon} is the
+square root of the machine precision @code{GSL_DBL_EPSILON}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfsolver_dif_fdf (const gsl_vector * @var{x}, gsl_multifit_function_fdf * @var{fdf}, gsl_vector * @var{f}, gsl_matrix * @var{J})
+This function is deprecated and will be removed in a future release.
+@end deftypefun
+
+@node Iteration of the Minimization Algorithm
+@section Iteration
+
+The following functions drive the iteration of each algorithm.  Each
+function performs one iteration to update the state of any solver of the
+corresponding type.  The same functions work for all solvers so that
+different methods can be substituted at runtime without modifications to
+the code.
+
+@deftypefun int gsl_multifit_fsolver_iterate (gsl_multifit_fsolver * @var{s})
+@deftypefunx int gsl_multifit_fdfsolver_iterate (gsl_multifit_fdfsolver * @var{s})
+@deftypefunx int gsl_multifit_fdfridge_iterate (gsl_multifit_fdfridge * @var{s})
+These functions perform a single iteration of the solver @var{s}.  If
+the iteration encounters an unexpected problem then an error code will
+be returned.  The solver maintains a current estimate of the best-fit
+parameters at all times. 
+@end deftypefun
+
+The solver struct @var{s} contains the following entries, which can
+be used to track the progress of the solution:
+
+@table @code
+@item gsl_vector * x
+The current position.
+
+@item gsl_vector * f
+The function residual vector at the current position @math{f(x)}.
+
+@item gsl_vector * dx
+The difference between the current position and the previous position,
+i.e. the last step @math{\delta}, taken as a vector.
+
+@end table
+
+The best-fit information also can be accessed with the following
+auxiliary functions,
+
+@deftypefun {gsl_vector *} gsl_multifit_fsolver_position (const gsl_multifit_fsolver * @var{s})
+@deftypefunx {gsl_vector *} gsl_multifit_fdfsolver_position (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx {gsl_vector *} gsl_multifit_fdfridge_position (const gsl_multifit_fdfridge * @var{s})
+These functions return the current position @math{x} (i.e. best-fit
+parameters) of the solver @var{s}.
+@end deftypefun
+
+@deftypefun {gsl_vector *} gsl_multifit_fdfsolver_residual (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx {gsl_vector *} gsl_multifit_fdfridge_residual (const gsl_multifit_fdfridge * @var{s})
+These functions return the current residual vector @math{f} of the
+solver @var{s}.  For weighted cases, the residual vector includes the
+weighting factor @math{\sqrt{W}}. For ridge regression, the residual
+vector is the augmented vector @math{\tilde{f}}.
+@end deftypefun
+
+@deftypefun size_t gsl_multifit_fdfsolver_niter (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx size_t gsl_multifit_fdfridge_niter (const gsl_multifit_fdfridge * @var{s})
+These functions return the number of iterations performed so far.
+The iteration counter is updated on each call to the
+@code{_iterate} functions above, and reset to 0 in the
+@code{_set} functions.
+@end deftypefun
+
+@node Search Stopping Parameters for Minimization Algorithms
+@section Search Stopping Parameters
+@cindex nonlinear fitting, stopping parameters
+
+A minimization procedure should stop when one of the following conditions is
+true:
+
+@itemize @bullet
+@item
+A minimum has been found to within the user-specified precision.
+
+@item
+A user-specified maximum number of iterations has been reached.
+
+@item
+An error has occurred.
+@end itemize
+
+@noindent
+The handling of these conditions is under user control.  The functions
+below allow the user to test the current estimate of the best-fit
+parameters in several standard ways.
+
+@deftypefun int gsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * @var{s}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
+This function tests for convergence of the minimization method
+using the following criteria:
+
+@itemize @bullet
+@item
+Testing for a small step size relative to the current parameter vector
+@tex
+\beforedisplay
+$$
+|\delta_i| \le xtol (|x_i| + xtol)
+$$
+\afterdisplay
+@end tex
+@ifinfo
+@example
+|\delta_i| <= xtol (|x_i| + xtol)
+@end example
+@end ifinfo
+for each @math{0 <= i < p}. Each element of the step vector @math{\delta}
+is tested individually in case the different parameters have widely
+different scales. Adding @var{xtol} to @math{|x_i|} helps the test avoid
+breaking down in situations where the true solution value @math{x_i = 0}.
+If this test succeeds, @var{info} is set to 1 and the function
+returns @code{GSL_SUCCESS}.
+
+A general guideline for selecting the step tolerance is to choose
+@math{xtol = 10^{-d}} where @math{d} is the number of accurate
+decimal digits desired in the solution @math{x}. See Dennis and
+Schnabel for more information.
+
+@item
+Testing for a small gradient (@math{g = \nabla \Phi(x) = J^T f})
+indicating a local function minimum:
+@tex
+\beforedisplay
+$$
+max_i |g_i \times max(x_i, 1)| \le gtol \times max(\Phi(x), 1)
+$$
+\afterdisplay
+@end tex
+@ifinfo
+@example
+||g||_inf <= gtol
+@end example
+@end ifinfo
+This expression tests whether the ratio
+@math{(\nabla \Phi)_i x_i / \Phi} is small. Testing this scaled gradient
+is a better than @math{\nabla \Phi} alone since it is a dimensionless
+quantity and so independent of the scale of the problem. The
+@code{max} arguments help ensure the test doesn't break down in
+regions where @math{x_i} or @math{\Phi(x)} are close to 0.
+If this test succeeds, @var{info} is set to 2 and the function
+returns @code{GSL_SUCCESS}.
+
+A general guideline for choosing the gradient tolerance is to set
+@code{gtol = GSL_DBL_EPSILON^(1/3)}. See Dennis and Schnabel for
+more information.
+
+@end itemize
+
+If none of the tests succeed, @var{info} is set to 0 and the
+function returns @code{GSL_CONTINUE}, indicating further iterations
+are required.
+
+@end deftypefun
+
+@deftypefun int gsl_multifit_test_delta (const gsl_vector * @var{dx}, const gsl_vector * @var{x}, double @var{epsabs}, double @var{epsrel})
+
+This function tests for the convergence of the sequence by comparing the
+last step @var{dx} with the absolute error @var{epsabs} and relative
+error @var{epsrel} to the current position @var{x}.  The test returns
+@code{GSL_SUCCESS} if the following condition is achieved,
+@tex
+\beforedisplay
+$$
+|dx_i| < \hbox{\it epsabs} + \hbox{\it epsrel\/}\, |x_i|
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+|dx_i| < epsabs + epsrel |x_i|
+@end example
+
+@end ifinfo
+@noindent
+for each component of @var{x} and returns @code{GSL_CONTINUE} otherwise.
+@end deftypefun
+
+@cindex residual, in nonlinear systems of equations
+@deftypefun int gsl_multifit_test_gradient (const gsl_vector * @var{g}, double @var{epsabs})
+This function tests the residual gradient @var{g} against the absolute
+error bound @var{epsabs}.  Mathematically, the gradient should be
+exactly zero at the minimum. The test returns @code{GSL_SUCCESS} if the
+following condition is achieved,
+@tex
+\beforedisplay
+$$
+\sum_i |g_i| < \hbox{\it epsabs}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\sum_i |g_i| < epsabs
+@end example
+
+@end ifinfo
+@noindent
+and returns @code{GSL_CONTINUE} otherwise.  This criterion is suitable
+for situations where the precise location of the minimum, @math{x},
+is unimportant provided a value can be found where the gradient is small
+enough.
+@end deftypefun
+
+
+@deftypefun int gsl_multifit_gradient (const gsl_matrix * @var{J}, const gsl_vector * @var{f}, gsl_vector * @var{g})
+This function computes the gradient @var{g} of @math{\Phi(x) = (1/2)
+||f(x)||^2} from the Jacobian matrix @math{J} and the function values
+@var{f}, using the formula @math{g = J^T f}.
+@end deftypefun
+
+@node High Level Driver
+@section High Level Driver
+
+These routines provide a high level wrapper that combine the iteration
+and convergence testing for easy use.
+
+@deftypefun int gsl_multifit_fsolver_driver (gsl_multifit_fsolver * @var{s}, const size_t @var{maxiter}, const double @var{epsabs}, const double @var{epsrel})
+This function iterates the solver @var{s} for a maximum of @var{maxiter}
+iterations. After each iteration, the system is tested for convergence
+using @code{gsl_multifit_test_delta} with the error tolerances @var{epsabs}
+and @var{epsrel}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfsolver_driver (gsl_multifit_fdfsolver * @var{s}, const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
+@deftypefunx int gsl_multifit_fdfridge_driver (gsl_multifit_fdfridge * @var{s}, const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
+These functions iterate the solver @var{s} for a maximum of @var{maxiter}
+iterations. After each iteration, the system is tested for convergence
+with the error tolerances @var{xtol}, @var{gtol} and @var{ftol}.
+Upon successful convergence,
+the function returns @code{GSL_SUCCESS} and sets @var{info} to
+the reason for convergence (see @code{gsl_multifit_fdfsolver_test}).
+Otherwise, the function returns @code{GSL_EMAXITER} indicating
+the system did not converge after @var{maxiter} iterations.
+@end deftypefun
+
+@node Minimization Algorithms using Derivatives
+@section Minimization Algorithms using Derivatives
+
+The minimization algorithms described in this section make use of both
+the function and its derivative.  They require an initial guess for the
+location of the minimum. There is no absolute guarantee of
+convergence---the function must be suitable for this technique and the
+initial guess must be sufficiently close to the minimum for it to work.
+
+@comment ============================================================
+@cindex Levenberg-Marquardt algorithms
+
+@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmsder
+@cindex LMDER algorithm
+@cindex MINPACK, minimization algorithms
+
+This is a robust and efficient version of the Levenberg-Marquardt
+algorithm as implemented in the scaled @sc{lmder} routine in
+@sc{minpack}.  Minpack was written by Jorge J. Mor@'e, Burton S. Garbow
+and Kenneth E. Hillstrom.
+
+The algorithm uses a generalized trust region to keep each step under
+control.  In order to be accepted a proposed new position @math{x'} must
+satisfy the condition @math{|D (x' - x)| < \Delta}, where @math{D} is a
+diagonal scaling matrix and @math{\Delta} is the size of the trust
+region.  The components of @math{D} are computed internally, using the
+column norms of the Jacobian to estimate the sensitivity of the residual
+to each component of @math{x}.  This improves the behavior of the
+algorithm for badly scaled functions.
+
+On each iteration the algorithm attempts to minimize the linear system
+@math{|f + J \delta|} subject to the constraint @math{|D \delta| < \Delta}.
+The solution to this constrained linear system is found by solving
+the linear least squares system
+@tex
+\beforedisplay
+$$
+\left[
+\matrix{
+J \cr
+\sqrt{\mu} D
+}
+\right]
+\delta =
+-
+\left[
+\matrix{
+f \cr
+0
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+[J; sqrt(mu) D] \delta = - [f; 0]
+@end example
+
+@end ifinfo
+where @math{\mu} is the Levenberg-Marquardt parameter. The above
+system is solved using a QR decomposition of @math{J}.
+
+The proposed step @math{\delta} is now tested by evaluating the
+function at the resulting point, @math{x'}.  If the step reduces the norm of the
+function sufficiently, and follows the predicted behavior of the
+function within the trust region, then it is accepted and the size of the
+trust region is increased.  If the proposed step fails to improve the
+solution, or differs significantly from the expected behavior within
+the trust region, then the size of the trust region is decreased and
+another trial step is computed.
+
+The algorithm also monitors the progress of the solution and returns an
+error if the changes in the solution are smaller than the machine
+precision.  The possible error codes are,
+
+@table @code
+@item GSL_ETOLF
+the decrease in the function falls below machine precision
+
+@item GSL_ETOLX
+the change in the position vector falls below machine precision
+
+@item GSL_ETOLG
+the norm of the gradient, relative to the norm of the function, falls
+below machine precision
+
+@item GSL_ENOPROG
+the routine has made 10 or more attempts to find a suitable trial step
+without success (but subsequent calls can be made to continue the
+search).@footnote{The return code @code{GSL_CONTINUE} was used for
+this case in versions prior to 1.14.}
+@end table
+
+@noindent
+These error codes indicate that further iterations will be unlikely to
+change the solution from its current value.  
+@end deffn
+
+@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmder
+
+This is an unscaled version of the @sc{lmder} algorithm.  The elements of the
+diagonal scaling matrix @math{D} are set to 1.  This algorithm may be
+useful in circumstances where the scaled version of @sc{lmder} converges too
+slowly, or the function is already scaled appropriately.
+@end deffn
+
+@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmniel
+
+This is a Levenberg-Marquardt solver based on a smoother updating
+procedure for the damping parameter @math{\mu} proposed by
+Nielsen, 1999. It does not use a trust region approach and only
+performs rudimentary scaling and is therefore not as robust as
+@code{lmsder}. However, on each iteration it solves the normal
+equation system to compute the next step:
+@tex
+\beforedisplay
+$$
+\left( J^T J + \mu I \right) \delta = - J^T f
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+(J^T J + \mu I) \delta = -J^T f
+@end example
+
+@end ifinfo
+which makes it a much more practical method for problems with a
+large number of residuals (@math{n >> p}), since only the
+@math{p}-by-@math{p} matrix @math{J^T J} is decomposed rather than
+the full @math{n}-by-@math{p} Jacobian. This makes a significant
+difference in efficiency when solving systems with large amounts
+of data. While not as robust as @code{lmsder}, this algorithm has
+proven effective on a wide class of problems.
+@end deffn
+
+@node Minimization Algorithms without Derivatives
+@section Minimization Algorithms without Derivatives
+
+There are no algorithms implemented in this section at the moment.
+
+@node Computing the covariance matrix of best fit parameters
+@section Computing the covariance matrix of best fit parameters
+@cindex best-fit parameters, covariance
+@cindex least squares, covariance of best-fit parameters
+@cindex covariance matrix, nonlinear fits
+
+@deftypefun int gsl_multifit_fdfsolver_jac (gsl_multifit_fdfsolver * @var{s}, gsl_matrix * @var{J})
+This function stores the @math{n}-by-@math{p} Jacobian matrix for the
+current iteration of the solver @var{s} into the output @var{J}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_covar (const gsl_matrix * @var{J}, const double @var{epsrel}, gsl_matrix * @var{covar})
+This function computes the covariance matrix of best-fit parameters
+using the Jacobian matrix @var{J} and stores it in @var{covar}.
+The parameter @var{epsrel} is used to remove linear-dependent columns
+when @var{J} is rank deficient.
+
+The covariance matrix is given by,
+@tex
+\beforedisplay
+$$
+C = (J^T J)^{-1}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+covar = (J^T J)^@{-1@}
+@end example
+
+@end ifinfo
+or in the weighted case,
+@tex
+\beforedisplay
+$$
+C = (J^T W J)^{-1}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+covar = (J^T W J)^@{-1@}
+@end example
+
+@end ifinfo
+@noindent
+and is computed by QR decomposition of J with column-pivoting.  Any
+columns of @math{R} which satisfy 
+@tex
+\beforedisplay
+$$
+|R_{kk}| \leq epsrel |R_{11}|
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+|R_@{kk@}| <= epsrel |R_@{11@}|
+@end example
+
+@end ifinfo
+@noindent
+are considered linearly-dependent and are excluded from the covariance
+matrix (the corresponding rows and columns of the covariance matrix are
+set to zero).
+
+If the minimisation uses the weighted least-squares function
+@math{f_i = (Y(x, t_i) - y_i) / \sigma_i} then the covariance
+matrix above gives the statistical error on the best-fit parameters
+resulting from the Gaussian errors @math{\sigma_i} on 
+the underlying data @math{y_i}.  This can be verified from the relation 
+@math{\delta f = J \delta c} and the fact that the fluctuations in @math{f}
+from the data @math{y_i} are normalised by @math{\sigma_i} and 
+so satisfy @c{$\langle \delta f \delta f^T \rangle = I$}
+@math{<\delta f \delta f^T> = I}.
+
+For an unweighted least-squares function @math{f_i = (Y(x, t_i) -
+y_i)} the covariance matrix above should be multiplied by the variance
+of the residuals about the best-fit @math{\sigma^2 = \sum (y_i - Y(x,t_i))^2 / (n-p)}
+to give the variance-covariance
+matrix @math{\sigma^2 C}.  This estimates the statistical error on the
+best-fit parameters from the scatter of the underlying data.
+
+For more information about covariance matrices see @ref{Fitting Overview}.
+@end deftypefun
+
+@comment ============================================================
+
+@node Troubleshooting Nonlinear Least Squares
+@section Troubleshooting
+
+When developing a code to solve a nonlinear least squares problem,
+here are a few considerations to keep in mind.
+
+@enumerate
+
+@item
+The most common difficulty is the accurate implementation of the Jacobian
+matrix. If the analytic Jacobian is not properly provided to the
+solver, this can hinder and many times prevent convergence of the method.
+When developing a new nonlinear least squares code, it often helps
+to compare the program output with the internally computed finite
+difference Jacobian and the user supplied analytic Jacobian. If there
+is a large difference in coefficients, it is likely the analytic
+Jacobian is incorrectly implemented.
+
+@item
+If your code is having difficulty converging, the next thing to
+check is the starting point provided to the solver. The methods
+of this chapter are local methods, meaning if you provide a starting
+point far away from the true minimum, the method may converge to
+a local minimum or not converge at all. Sometimes it is possible
+to solve a linearized approximation to the nonlinear problem,
+and use the linear solution as the starting point to the nonlinear
+problem.
+
+@item
+If the various parameters of the coefficient vector @math{x}
+vary widely in magnitude, then the problem is said to be badly scaled.
+The methods of this chapter do attempt to automatically rescale
+the elements of @math{x} to have roughly the same order of magnitude,
+but in extreme cases this could still cause problems for convergence.
+In these cases it is recommended for the user to scale their
+parameter vector @math{x} so that each parameter spans roughly the
+same range, say @math{[-1,1]}. The solution vector can be backscaled
+to recover the original units of the problem.
+
+@end enumerate
+
+@node Example programs for Nonlinear Least-Squares Fitting
+@section Examples
+
+The following example program fits a weighted exponential model with
+background to experimental data, @math{Y = A \exp(-\lambda t) + b}. The
+first part of the program sets up the functions @code{expb_f} and
+@code{expb_df} to calculate the model and its Jacobian.  The appropriate
+fitting function is given by,
+@tex
+\beforedisplay
+$$
+f_i = (A \exp(-\lambda t_i) + b) - y_i
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f_i = (A \exp(-\lambda t_i) + b) - y_i
+@end example
+
+@end ifinfo
+@noindent
+where we have chosen @math{t_i = i}.  The Jacobian matrix @math{J} is
+the derivative of these functions with respect to the three parameters
+(@math{A}, @math{\lambda}, @math{b}).  It is given by,
+@tex
+\beforedisplay
+$$
+J_{ij} = {\partial f_i \over \partial x_j}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+J_@{ij@} = d f_i / d x_j
+@end example
+
+@end ifinfo
+@noindent
+where @math{x_0 = A}, @math{x_1 = \lambda} and @math{x_2 = b}. The
+weights are given by @math{w_i = 1/\sigma_i^2}.
+
+@example
+@verbatiminclude examples/expfit.c
+@end example
+
+@noindent
+The main part of the program sets up a Levenberg-Marquardt solver and
+some simulated random data. The data uses the known parameters
+(5.0,0.1,1.0) combined with Gaussian noise (standard deviation = 0.1)
+over a range of 40 timesteps. The initial guess for the parameters is
+chosen as (0.0, 1.0, 0.0).
+
+@example
+@verbatiminclude examples/nlfit.c
+@end example
+
+@noindent
+The iteration terminates when the relative change in x is smaller than
+@math{10^{-8}}, or when the magnitude of the gradient falls below
+@math{10^{-8}}.
+Here are the results of running the program:
+
+@smallexample
+summary from method 'lmsder'
+number of iterations: 8
+function evaluations: 11
+Jacobian evaluations: 9
+reason for stopping: small step size
+initial |f(x)| = 31.1919
+final   |f(x)| = 5.45418
+chisq/dof = 0.804002
+A      = 5.17379 +/- 0.27938
+lambda = 0.11104 +/- 0.00817
+b      = 1.05283 +/- 0.05365
+status = success
+@end smallexample
+
+@noindent
+The approximate values of the parameters are found correctly, and the
+chi-squared value indicates a good fit (the chi-squared per degree of
+freedom is approximately 1).  In this case the errors on the parameters
+can be estimated from the square roots of the diagonal elements of the
+covariance matrix.  
+
+If the chi-squared value shows a poor fit (i.e. @c{$\chi^2/(n-p) \gg 1$}
+@math{chi^2/dof >> 1}) then the error estimates obtained from the
+covariance matrix will be too small.  In the example program the error estimates
+are multiplied by @c{$\sqrt{\chi^2/(n-p)}$}
+@math{\sqrt@{\chi^2/dof@}} in this case, a common way of increasing the
+errors for a poor fit.  Note that a poor fit will result from the use
+an inappropriate model, and the scaled error estimates may then
+be outside the range of validity for Gaussian errors.
+
+@iftex
+@sp 1
+@center @image{fit-exp,3.4in}
+@end iftex
+
+@node References and Further Reading for Nonlinear Least-Squares Fitting
+@section References and Further Reading
+
+The @sc{minpack} algorithm is described in the following article,
+
+@itemize @w{}
+@item
+J.J. Mor@'e, @cite{The Levenberg-Marquardt Algorithm: Implementation and
+Theory}, Lecture Notes in Mathematics, v630 (1978), ed G. Watson.
+@end itemize
+
+@noindent
+The @code{lmniel} algorithm closely follows the following publications,
+
+@itemize @w{}
+@item
+H. B. Nielsen, ``Damping Parameter in Marquardt's Method'',
+IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-1999-05
+(1999).
+
+@item
+K. Madsen and H. B. Nielsen, ``Introduction to Optimization and Data
+Fitting'', IMM Department of Mathematical Modeling, DTU, 2010.
+@end itemize
+
+@noindent
+The following publications are also relevant to the algorithms described
+in this section,
+
+@itemize @w{}
+@item
+J. E. Dennis and R. B. Schnabel, Numerical Methods for Unconstrained
+Optimization and Nonlinear Equations, SIAM, 1996.
+
+@item 
+J.J. Mor@'e, B.S. Garbow, K.E. Hillstrom, ``Testing Unconstrained
+Optimization Software'', ACM Transactions on Mathematical Software, Vol
+7, No 1 (1981), p 17--41.
+
+@item 
+H. B. Nielsen, ``UCTP Test Problems for Unconstrained Optimization'',
+IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-2000-17
+(2000).
+@end itemize
+
diff --git a/gsl.pc.cmake b/gsl.pc.cmake
new file mode 100644
index 0000000..6f313c1
--- /dev/null
+++ b/gsl.pc.cmake
@@ -0,0 +1,11 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=${prefix}/lib
+includedir=${prefix}/include
+GSL_CBLAS_LIB=-lgslcblas
+
+Name: GSL
+Description: GNU Scientific Library
+Version: @PACKAGE_VERSION@
+Libs: -L${libdir} -lgsl ${GSL_CBLAS_LIB} -lm -lm
+Cflags: -I${includedir}
diff --git a/ieee-utils/fp-win.c b/ieee-utils/fp-win.c
new file mode 100644
index 0000000..e024eae
--- /dev/null
+++ b/ieee-utils/fp-win.c
@@ -0,0 +1,70 @@
+/* fp-win.c
+ * 
+ * Author: Brian Gladman
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <float.h>
+
+#include <config.h>
+#include <gsl/gsl_ieee_utils.h>
+#include <gsl/gsl_errno.h>
+
+const char *fp_env_string = "round-to-nearest,double-precision,mask-all";
+
+int
+gsl_ieee_set_mode (int precision, int rounding, int exception_mask)
+{
+	unsigned int old, mode = _DN_SAVE, mask = _MCW_DN | _MCW_RC | _MCW_EM;
+
+	switch(precision)
+    {
+    case GSL_IEEE_SINGLE_PRECISION:		mode |= _PC_24; break;
+    case GSL_IEEE_EXTENDED_PRECISION:	mode |= _PC_64; break;
+    case GSL_IEEE_DOUBLE_PRECISION:
+    default:							mode |= _PC_53;
+	}
+#ifndef _M_AMD64
+	mask |= _MCW_PC;
+#endif
+
+	switch(rounding)
+    {
+    case GSL_IEEE_ROUND_DOWN:			mode |= _RC_DOWN; break;
+    case GSL_IEEE_ROUND_UP:				mode |= _RC_UP;   break;
+    case GSL_IEEE_ROUND_TO_ZERO:		mode |= _RC_CHOP; break;
+    case GSL_IEEE_ROUND_TO_NEAREST:
+    default:							mode |= _RC_NEAR;
+    }
+
+	if(exception_mask & GSL_IEEE_MASK_INVALID)
+		mode |= _EM_INVALID;
+	if(exception_mask & GSL_IEEE_MASK_DENORMALIZED)
+		mode |= _EM_DENORMAL;
+	if(exception_mask & GSL_IEEE_MASK_DIVISION_BY_ZERO)
+		mode |= _EM_ZERODIVIDE;
+	if(exception_mask & GSL_IEEE_MASK_OVERFLOW)
+		mode |= _EM_OVERFLOW;
+	if(exception_mask & GSL_IEEE_MASK_UNDERFLOW)
+		mode |= _EM_UNDERFLOW;
+	if(exception_mask & GSL_IEEE_TRAP_INEXACT)
+		mode &= ~_EM_INEXACT;
+	else
+		mode |= _EM_INEXACT;
+
+	_controlfp_s( &old, mode, mask);
+	return GSL_SUCCESS;
+}
-- 
2.10.0

From 05ddb52038a4d34f7b31428c47cccedc4752c1ac Mon Sep 17 00:00:00 2001
From: Filipe Brandao <fdabrandao@gmail.com>
Date: Fri, 16 Sep 2016 13:46:10 -0400
Subject: [PATCH] Remove deprecated files

---
 doc/examples/expfit.c |   56 ---
 doc/multifit.texi     | 1170 -------------------------------------------------
 ieee-utils/fp-win.c   |   70 ---
 3 files changed, 1296 deletions(-)
 delete mode 100644 doc/examples/expfit.c
 delete mode 100644 doc/multifit.texi
 delete mode 100644 ieee-utils/fp-win.c

diff --git a/doc/examples/expfit.c b/doc/examples/expfit.c
deleted file mode 100644
index 328177a..0000000
--- a/doc/examples/expfit.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/* expfit.c -- model functions for exponential + background */
-
-struct data {
-  size_t n;
-  double * y;
-};
-
-int
-expb_f (const gsl_vector * x, void *data, 
-        gsl_vector * f)
-{
-  size_t n = ((struct data *)data)->n;
-  double *y = ((struct data *)data)->y;
-
-  double A = gsl_vector_get (x, 0);
-  double lambda = gsl_vector_get (x, 1);
-  double b = gsl_vector_get (x, 2);
-
-  size_t i;
-
-  for (i = 0; i < n; i++)
-    {
-      /* Model Yi = A * exp(-lambda * i) + b */
-      double t = i;
-      double Yi = A * exp (-lambda * t) + b;
-      gsl_vector_set (f, i, Yi - y[i]);
-    }
-
-  return GSL_SUCCESS;
-}
-
-int
-expb_df (const gsl_vector * x, void *data, 
-         gsl_matrix * J)
-{
-  size_t n = ((struct data *)data)->n;
-
-  double A = gsl_vector_get (x, 0);
-  double lambda = gsl_vector_get (x, 1);
-
-  size_t i;
-
-  for (i = 0; i < n; i++)
-    {
-      /* Jacobian matrix J(i,j) = dfi / dxj, */
-      /* where fi = (Yi - yi)/sigma[i],      */
-      /*       Yi = A * exp(-lambda * i) + b  */
-      /* and the xj are the parameters (A,lambda,b) */
-      double t = i;
-      double e = exp(-lambda * t);
-      gsl_matrix_set (J, i, 0, e); 
-      gsl_matrix_set (J, i, 1, -t * A * e);
-      gsl_matrix_set (J, i, 2, 1.0);
-    }
-  return GSL_SUCCESS;
-}
diff --git a/doc/multifit.texi b/doc/multifit.texi
deleted file mode 100644
index 318eddc..0000000
--- a/doc/multifit.texi
+++ /dev/null
@@ -1,1170 +0,0 @@
-@cindex nonlinear least squares fitting
-@cindex least squares fitting, nonlinear
-
-This chapter describes functions for multidimensional nonlinear
-least-squares fitting.  The library provides low level components for a
-variety of iterative solvers and convergence tests.  These can be
-combined by the user to achieve the desired solution, with full access
-to the intermediate steps of the iteration.  Each class of methods uses
-the same framework, so that you can switch between solvers at runtime
-without needing to recompile your program.  Each instance of a solver
-keeps track of its own state, allowing the solvers to be used in
-multi-threaded programs.
-
-The header file @file{gsl_multifit_nlin.h} contains prototypes for the
-multidimensional nonlinear fitting functions and related declarations.
-
-@menu
-* Overview of Nonlinear Least-Squares Fitting::  
-* Overview of Weighted Nonlinear Least-Squares Fitting::  
-* Overview of Regularized Nonlinear Least-Squares Fitting::  
-* Initializing the Nonlinear Least-Squares Solver::  
-* Providing the Function to be Minimized::  
-* Finite Difference Jacobian::  
-* Iteration of the Minimization Algorithm::  
-* Search Stopping Parameters for Minimization Algorithms::  
-* High Level Driver::
-* Minimization Algorithms using Derivatives::  
-* Minimization Algorithms without Derivatives::  
-* Computing the covariance matrix of best fit parameters::  
-* Troubleshooting Nonlinear Least Squares::
-* Example programs for Nonlinear Least-Squares Fitting::  
-* References and Further Reading for Nonlinear Least-Squares Fitting::  
-@end menu
-
-@node Overview of Nonlinear Least-Squares Fitting
-@section Overview
-@cindex nonlinear least squares fitting, overview
-
-The problem of multidimensional nonlinear least-squares fitting requires
-the minimization of the squared residuals of @math{n} functions,
-@math{f_i}, in @math{p} parameters, @math{x_i},
-@tex
-\beforedisplay
-$$
-\Phi(x)  = {1 \over 2} || f(x) ||^2
-         = {1 \over 2} \sum_{i=1}^{n} f_i (x_1, \dots, x_p)^2
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-\Phi(x) = (1/2) || f(x) ||^2
-        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
-@end example
-
-@end ifinfo
-@noindent
-All algorithms proceed from an initial guess using the linearization,
-@tex
-\beforedisplay
-$$
-\psi(\delta) = || f(x+\delta) || \approx || f(x) + J \delta\, ||
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-\psi(\delta) = || f(x+\delta) || ~=~ || f(x) + J \delta ||
-@end example
-
-@end ifinfo
-@noindent
-where @math{x} is the initial point, @math{\delta} is the proposed step
-and @math{J} is the
-Jacobian matrix @c{$J_{ij} = \partial f_i / \partial x_j$}
-@math{J_@{ij@} = d f_i / d x_j}.  
-Additional strategies are used to enlarge the region of convergence.
-These include requiring a decrease in the norm @math{||f||} on each
-step or using a trust region to avoid steps which fall outside the linear 
-regime.
-
-@noindent
-Note that the model parameters are denoted by @math{x} in this chapter
-since the non-linear least-squares algorithms are described
-geometrically (i.e. finding the minimum of a surface).  The
-independent variable of any data to be fitted is denoted by @math{t}.
-
-@node Overview of Weighted Nonlinear Least-Squares Fitting
-@section Weighted Nonlinear Least-Squares
-
-Weighted nonlinear least-squares fitting minimizes the function
-@tex
-\beforedisplay
-$$
-\Phi(x)  = {1 \over 2} f^T W f
-         = {1 \over 2} \sum_{i=1}^{n} w_i f_i (x_1, \dots, x_p)^2
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-\Phi(x) = (1/2) || f(x) ||^2
-        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
-@end example
-
-@end ifinfo
-where @math{W = diag(w_1,w_2,...,w_n)} is the weighting matrix,
-and the weights @math{w_i} are commonly defined as @math{w_i = 1/\sigma_i^2},
-where @math{\sigma_i} is the error in the @math{i}th measurement.
-A simple change of variables @math{\tilde{f} = \sqrt{W} f} yields
-@math{\Phi(x) = {1 \over 2} ||\tilde{f}||^2}, which is in the
-same form as the unweighted case. The user can either perform this
-transform directly on their function residuals and Jacobian, or use
-the @code{gsl_multifit_fdfsolver_wset} interface which automatically
-performs the correct scaling. To manually perform this transformation,
-the residuals and Jacobian should be modified according to
-@tex
-\beforedisplay
-$$
-\eqalign{
-f_i & = \sqrt{w_i} (Y_i - y_i) = {(Y_i - y_i) \over \sigma_i} \cr
-J_{ij} & = \sqrt{w_i} { \partial Y_i \over \partial x_j } = { 1 \over \sigma_i} { \partial Y_i \over \partial x_j }
-}
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-f_i = (Y(x, t_i) - y_i) / \sigma_i
-@end example
-
-@end ifinfo
-where @math{Y_i = Y(x,t_i)}.
-
-@node Overview of Regularized Nonlinear Least-Squares Fitting
-@section Regularized Nonlinear Least-Squares
-In cases where the Jacobian @math{J} is rank-deficient or singular,
-standard nonlinear least squares can sometimes produce
-undesirable and unstable solutions. In these cases, it can
-help to regularize the problem using ridge or Tikhonov regularization.
-In this method, we introduce a term in our minimization function
-which is designed to damp the solution vector @math{x}, or give preference
-to solutions with smaller norms.
-@tex
-\beforedisplay
-$$
-\Phi(x)  = {1 \over 2} || f(x) ||^2 + {1 \over 2} || L x ||^2
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-\Phi(x) = (1/2) || f(x) ||^2 + (1/2) ||Lx||^2
-@end example
-
-@end ifinfo
-Here, the regularization matrix @math{L} is often set
-as @math{L = \lambda I}, for a positive scalar @math{\lambda}, but can
-also be a general @math{m}-by-@math{p} (where @math{m} is any number
-of rows) matrix depending on the
-structure of the problem to be solved. If we define a new
-@math{(n+m)}-by-1 vector
-@tex
-\beforedisplay
-$$
-\tilde{f}(x) =
-\left[
-\matrix{
-f(x) \cr
-L x
-}
-\right]
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-f~(x) = [ f(x); Lx ]
-@end example
-
-@end ifinfo
-or, in the weighted case,
-@tex
-\beforedisplay
-$$
-\tilde{f}(x) =
-\left[
-\matrix{
-\sqrt{W} f(x) \cr
-L x
-}
-\right]
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-f~(x) = [ sqrt(W) f(x); Lx ]
-@end example
-
-@end ifinfo
-then
-@tex
-\beforedisplay
-$$
-\Phi(x)  = {1 \over 2} || \tilde{f}(x) ||^2
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-\Phi(x) = (1/2) || f~(x) ||^2
-@end example
-
-@end ifinfo
-which is in the same form as the standard nonlinear least squares
-problem. The corresponding @math{(n+m)}-by-@math{p} Jacobian matrix is
-@tex
-\beforedisplay
-$$
-\tilde{J} =
-\left[
-\matrix{
-J \cr
-L
-}
-\right]
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-F~(x) = [ J; L ]
-@end example
-
-@end ifinfo
-or for weighted systems
-@tex
-\beforedisplay
-$$
-\tilde{J} =
-\left[
-\matrix{
-\sqrt{W} J \cr
-L
-}
-\right]
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-F~(x) = [ sqrt(W) J; L ]
-@end example
-
-@end ifinfo
-While the user could explicitly form the @math{\tilde{f}(x)} vector
-and @math{\tilde{J}} matrix, the @code{fdfridge} interface
-described below allows the user to specify the original data vector
-@math{f(x)}, Jacobian @math{J}, regularization matrix
-@math{L}, and optional weighting matrix @math{W}, and automatically
-forms @math{\tilde{f}(x)} and
-@math{\tilde{J}} to solve the system. This allows switching
-between regularized and non-regularized solutions with minimal
-code changes.
-
-@node Initializing the Nonlinear Least-Squares Solver
-@section Initializing the Solver
-
-@deftypefun {gsl_multifit_fsolver *} gsl_multifit_fsolver_alloc (const gsl_multifit_fsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
-@tindex gsl_multifit_fsolver
-@tindex gsl_multifit_fsolver_type
-This function returns a pointer to a newly allocated instance of a
-solver of type @var{T} for @var{n} observations and @var{p} parameters.
-The number of observations @var{n} must be greater than or equal to
-parameters @var{p}. 
-
-If there is insufficient memory to create the solver then the function
-returns a null pointer and the error handler is invoked with an error
-code of @code{GSL_ENOMEM}.
-@end deftypefun
-
-@deftypefun {gsl_multifit_fdfsolver *} gsl_multifit_fdfsolver_alloc (const gsl_multifit_fdfsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
-@tindex gsl_multifit_fdfsolver
-@tindex gsl_multifit_fdfsolver_type
-This function returns a pointer to a newly allocated instance of a
-derivative solver of type @var{T} for @var{n} observations and @var{p}
-parameters.  For example, the following code creates an instance of a
-Levenberg-Marquardt solver for 100 data points and 3 parameters,
-
-@example
-const gsl_multifit_fdfsolver_type * T 
-    = gsl_multifit_fdfsolver_lmder;
-gsl_multifit_fdfsolver * s 
-    = gsl_multifit_fdfsolver_alloc (T, 100, 3);
-@end example
-
-@noindent
-The number of observations @var{n} must be greater than or equal to
-parameters @var{p}.
-
-If there is insufficient memory to create the solver then the function
-returns a null pointer and the error handler is invoked with an error
-code of @code{GSL_ENOMEM}.
-@end deftypefun
-
-@deftypefun {gsl_multifit_fdfridge *} gsl_multifit_fdfridge_alloc (const gsl_multifit_fdfsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
-@tindex gsl_multifit_fdfridge
-This function returns a pointer to a newly allocated instance of a
-derivative solver of type @var{T} for @var{n} observations and @var{p}
-parameters. The solver will automatically form the augmented
-system @math{\tilde{f}(x)} and @math{\tilde{J}} for ridge (Tikhonov)
-regression.
-If there is insufficient memory to create the solver then the function
-returns a null pointer and the error handler is invoked with an error
-code of @code{GSL_ENOMEM}.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fsolver_set (gsl_multifit_fsolver * @var{s}, gsl_multifit_function * @var{f}, const gsl_vector * @var{x})
-This function initializes, or reinitializes, an existing solver @var{s}
-to use the function @var{f} and the initial guess @var{x}.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x})
-@deftypefunx int gsl_multifit_fdfsolver_wset (gsl_multifit_fdfsolver * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{wts})
-These functions initialize, or reinitialize, an existing solver @var{s}
-to use the function and derivative @var{fdf} and the initial guess
-@var{x}.
-
-Optionally, a weight vector @var{wts} can be given to perform
-a weighted nonlinear regression. Here, the weighting matrix is
-@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
-throughout the iteration so it should not be freed by the caller until
-the iteration terminates.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fdfridge_set (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const double @var{lambda})
-@deftypefunx int gsl_multifit_fdfridge_wset (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const double @var{lambda}, const gsl_vector * @var{wts})
-This function initializes, or reinitializes, an existing ridge solver
-@var{s} to use the function and derivative @var{fdf} and the initial guess
-@var{x}. Here, the regularization matrix is set to @math{L = \lambda I},
-with @math{\lambda} specified in @var{lambda}.
-
-Optionally, a weight vector @var{wts} can be given to perform
-a weighted nonlinear regression. Here, the weighting matrix is
-@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
-throughout the iteration so it should not be freed by the caller until
-the iteration terminates.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fdfridge_set2 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{lambda})
-@deftypefunx int gsl_multifit_fdfridge_wset2 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{lambda}, const gsl_vector * @var{wts})
-This function initializes, or reinitializes, an existing ridge solver
-@var{s} to use the function and derivative @var{fdf} and the initial
-guess @var{x}. Here, the regularization matrix is set to
-@math{L = diag(\lambda_1,\lambda_2,...,\lambda_p)}, where
-the @math{\lambda_i} are given in @var{lambda}.
-
-Optionally, a weight vector @var{wts} can be given to perform
-a weighted nonlinear regression. Here, the weighting matrix is
-@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
-throughout the iteration so it should not be freed by the caller until
-the iteration terminates.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fdfridge_set3 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_matrix * @var{L})
-@deftypefunx int gsl_multifit_fdfridge_wset3 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_matrix * @var{L}, const gsl_vector * @var{wts})
-This function initializes, or reinitializes, an existing ridge solver
-@var{s} to use the function and derivative @var{fdf} and the initial
-guess @var{x}. Here, the regularization matrix is set to @var{L},
-which must have @math{p} columns but may have any number of rows.
-
-Optionally, a weight vector @var{wts} can be given to perform
-a weighted nonlinear regression. Here, the weighting matrix is
-@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
-throughout the iteration so it should not be freed by the caller until
-the iteration terminates.
-@end deftypefun
-
-@deftypefun void gsl_multifit_fsolver_free (gsl_multifit_fsolver * @var{s})
-@deftypefunx void gsl_multifit_fdfsolver_free (gsl_multifit_fdfsolver * @var{s})
-@deftypefunx void gsl_multifit_fdfridge_free (gsl_multifit_fdfridge * @var{s})
-These functions free all the memory associated with the solver @var{s}.
-@end deftypefun
-
-@deftypefun {const char *} gsl_multifit_fsolver_name (const gsl_multifit_fsolver * @var{s})
-@deftypefunx {const char *} gsl_multifit_fdfsolver_name (const gsl_multifit_fdfsolver * @var{s})
-@deftypefunx {const char *} gsl_multifit_fdfridge_name (const gsl_multifit_fdfridge * @var{s})
-These functions return a pointer to the name of the solver.  For example,
-
-@example
-printf ("s is a '%s' solver\n", 
-        gsl_multifit_fdfsolver_name (s));
-@end example
-
-@noindent
-would print something like @code{s is a 'lmder' solver}.
-@end deftypefun
-
-@node Providing the Function to be Minimized
-@section Providing the Function to be Minimized
-
-You must provide @math{n} functions of @math{p} variables for the
-minimization algorithms to operate on.  In order to allow for
-arbitrary parameters the functions are defined by the following data
-types:
-
-@deftp {Data Type} gsl_multifit_function 
-This data type defines a general system of functions with arbitrary parameters.  
-
-@table @code
-@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
-this function should store the vector result
-@c{$f(x,\hbox{\it params})$}
-@math{f(x,params)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
-returning an appropriate error code if the function cannot be computed.
-
-@item size_t n
-the number of functions, i.e. the number of components of the
-vector @var{f}.
-
-@item size_t p
-the number of independent variables, i.e. the number of components of
-the vector @var{x}.
-
-@item void * params
-a pointer to the arbitrary parameters of the function.
-@end table
-@end deftp
-
-@deftp {Data Type} gsl_multifit_function_fdf
-This data type defines a general system of functions with arbitrary parameters and
-the corresponding Jacobian matrix of derivatives,
-
-@table @code
-@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
-this function should store the vector result
-@c{$f(x,\hbox{\it params})$}
-@math{f(x,params)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
-returning an appropriate error code if the function cannot be computed.
-
-@item int (* df) (const gsl_vector * @var{x}, void * @var{params}, gsl_matrix * @var{J})
-this function should store the @var{n}-by-@var{p} matrix result
-@c{$J_{ij} = \partial f_i(x,\hbox{\it params}) / \partial x_j$}
-@math{J_ij = d f_i(x,params) / d x_j} in @var{J} for argument @var{x} 
-and arbitrary parameters @var{params}, returning an appropriate error code if the
-function cannot be computed. If an analytic Jacobian is unavailable, or too expensive
-to compute, this function pointer may be set to NULL, in which
-case the Jacobian will be internally computed using finite difference approximations
-of the function @var{f}.
-
-@item size_t n
-the number of functions, i.e. the number of components of the
-vector @var{f}.
-
-@item size_t p
-the number of independent variables, i.e. the number of components of
-the vector @var{x}.
-
-@item void * params
-a pointer to the arbitrary parameters of the function.
-
-@item size_t nevalf
-This does not need to be set by the user. It counts the number of
-function evaluations and is initialized by the @code{_set} function.
-
-@item size_t nevaldf
-This does not need to be set by the user. It counts the number of
-Jacobian evaluations and is initialized by the @code{_set} function.
-@end table
-@end deftp
-
-Note that when fitting a non-linear model against experimental data,
-the data is passed to the functions above using the
-@var{params} argument and the trial best-fit parameters through the
-@var{x} argument.
-
-@node Finite Difference Jacobian
-@section Finite Difference Jacobian
-
-For the algorithms which require a Jacobian matrix of derivatives of
-the fit functions, there are times when an analytic Jacobian may be
-unavailable or too expensive to compute. Therefore GSL supports
-approximating the Jacobian numerically using finite differences of the fit
-functions. This is typically done by setting the relevant function pointers
-of the @code{gsl_multifit_function_fdf} data type to NULL, however the
-following functions allow the user to access the approximate Jacobian
-directly if needed.
-
-@deftypefun int gsl_multifit_fdfsolver_dif_df (const gsl_vector * @var{x}, const gsl_vector * @var{wts}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{f}, gsl_matrix * @var{J})
-This function takes as input the current position @var{x}, weight
-vector @var{wts} and function values computed at the current position
-@var{f}, along with @var{fdf} which specifies the fit function and
-parameters and approximates the
-@var{n}-by-@var{p} Jacobian @var{J} using forward finite differences:
-@c{$J_{ij} = \sqrt{w_i} \partial f_i(x) / \partial x_j \approx \sqrt{w_i} (f_i(x + h_j e_j) - f_i(x)) / h_j$}
-@math{J_ij = sqrt(w_i) d f_i(x) / d x_j = sqrt(w_i) (f_i(x + h_j e_j) - f_i(x)) / h_j}.
-where @math{h_j = \epsilon |x_j|}, and @math{\epsilon} is the
-square root of the machine precision @code{GSL_DBL_EPSILON}.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fdfsolver_dif_fdf (const gsl_vector * @var{x}, gsl_multifit_function_fdf * @var{fdf}, gsl_vector * @var{f}, gsl_matrix * @var{J})
-This function is deprecated and will be removed in a future release.
-@end deftypefun
-
-@node Iteration of the Minimization Algorithm
-@section Iteration
-
-The following functions drive the iteration of each algorithm.  Each
-function performs one iteration to update the state of any solver of the
-corresponding type.  The same functions work for all solvers so that
-different methods can be substituted at runtime without modifications to
-the code.
-
-@deftypefun int gsl_multifit_fsolver_iterate (gsl_multifit_fsolver * @var{s})
-@deftypefunx int gsl_multifit_fdfsolver_iterate (gsl_multifit_fdfsolver * @var{s})
-@deftypefunx int gsl_multifit_fdfridge_iterate (gsl_multifit_fdfridge * @var{s})
-These functions perform a single iteration of the solver @var{s}.  If
-the iteration encounters an unexpected problem then an error code will
-be returned.  The solver maintains a current estimate of the best-fit
-parameters at all times. 
-@end deftypefun
-
-The solver struct @var{s} contains the following entries, which can
-be used to track the progress of the solution:
-
-@table @code
-@item gsl_vector * x
-The current position.
-
-@item gsl_vector * f
-The function residual vector at the current position @math{f(x)}.
-
-@item gsl_vector * dx
-The difference between the current position and the previous position,
-i.e. the last step @math{\delta}, taken as a vector.
-
-@end table
-
-The best-fit information also can be accessed with the following
-auxiliary functions,
-
-@deftypefun {gsl_vector *} gsl_multifit_fsolver_position (const gsl_multifit_fsolver * @var{s})
-@deftypefunx {gsl_vector *} gsl_multifit_fdfsolver_position (const gsl_multifit_fdfsolver * @var{s})
-@deftypefunx {gsl_vector *} gsl_multifit_fdfridge_position (const gsl_multifit_fdfridge * @var{s})
-These functions return the current position @math{x} (i.e. best-fit
-parameters) of the solver @var{s}.
-@end deftypefun
-
-@deftypefun {gsl_vector *} gsl_multifit_fdfsolver_residual (const gsl_multifit_fdfsolver * @var{s})
-@deftypefunx {gsl_vector *} gsl_multifit_fdfridge_residual (const gsl_multifit_fdfridge * @var{s})
-These functions return the current residual vector @math{f} of the
-solver @var{s}.  For weighted cases, the residual vector includes the
-weighting factor @math{\sqrt{W}}. For ridge regression, the residual
-vector is the augmented vector @math{\tilde{f}}.
-@end deftypefun
-
-@deftypefun size_t gsl_multifit_fdfsolver_niter (const gsl_multifit_fdfsolver * @var{s})
-@deftypefunx size_t gsl_multifit_fdfridge_niter (const gsl_multifit_fdfridge * @var{s})
-These functions return the number of iterations performed so far.
-The iteration counter is updated on each call to the
-@code{_iterate} functions above, and reset to 0 in the
-@code{_set} functions.
-@end deftypefun
-
-@node Search Stopping Parameters for Minimization Algorithms
-@section Search Stopping Parameters
-@cindex nonlinear fitting, stopping parameters
-
-A minimization procedure should stop when one of the following conditions is
-true:
-
-@itemize @bullet
-@item
-A minimum has been found to within the user-specified precision.
-
-@item
-A user-specified maximum number of iterations has been reached.
-
-@item
-An error has occurred.
-@end itemize
-
-@noindent
-The handling of these conditions is under user control.  The functions
-below allow the user to test the current estimate of the best-fit
-parameters in several standard ways.
-
-@deftypefun int gsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * @var{s}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
-This function tests for convergence of the minimization method
-using the following criteria:
-
-@itemize @bullet
-@item
-Testing for a small step size relative to the current parameter vector
-@tex
-\beforedisplay
-$$
-|\delta_i| \le xtol (|x_i| + xtol)
-$$
-\afterdisplay
-@end tex
-@ifinfo
-@example
-|\delta_i| <= xtol (|x_i| + xtol)
-@end example
-@end ifinfo
-for each @math{0 <= i < p}. Each element of the step vector @math{\delta}
-is tested individually in case the different parameters have widely
-different scales. Adding @var{xtol} to @math{|x_i|} helps the test avoid
-breaking down in situations where the true solution value @math{x_i = 0}.
-If this test succeeds, @var{info} is set to 1 and the function
-returns @code{GSL_SUCCESS}.
-
-A general guideline for selecting the step tolerance is to choose
-@math{xtol = 10^{-d}} where @math{d} is the number of accurate
-decimal digits desired in the solution @math{x}. See Dennis and
-Schnabel for more information.
-
-@item
-Testing for a small gradient (@math{g = \nabla \Phi(x) = J^T f})
-indicating a local function minimum:
-@tex
-\beforedisplay
-$$
-max_i |g_i \times max(x_i, 1)| \le gtol \times max(\Phi(x), 1)
-$$
-\afterdisplay
-@end tex
-@ifinfo
-@example
-||g||_inf <= gtol
-@end example
-@end ifinfo
-This expression tests whether the ratio
-@math{(\nabla \Phi)_i x_i / \Phi} is small. Testing this scaled gradient
-is a better than @math{\nabla \Phi} alone since it is a dimensionless
-quantity and so independent of the scale of the problem. The
-@code{max} arguments help ensure the test doesn't break down in
-regions where @math{x_i} or @math{\Phi(x)} are close to 0.
-If this test succeeds, @var{info} is set to 2 and the function
-returns @code{GSL_SUCCESS}.
-
-A general guideline for choosing the gradient tolerance is to set
-@code{gtol = GSL_DBL_EPSILON^(1/3)}. See Dennis and Schnabel for
-more information.
-
-@end itemize
-
-If none of the tests succeed, @var{info} is set to 0 and the
-function returns @code{GSL_CONTINUE}, indicating further iterations
-are required.
-
-@end deftypefun
-
-@deftypefun int gsl_multifit_test_delta (const gsl_vector * @var{dx}, const gsl_vector * @var{x}, double @var{epsabs}, double @var{epsrel})
-
-This function tests for the convergence of the sequence by comparing the
-last step @var{dx} with the absolute error @var{epsabs} and relative
-error @var{epsrel} to the current position @var{x}.  The test returns
-@code{GSL_SUCCESS} if the following condition is achieved,
-@tex
-\beforedisplay
-$$
-|dx_i| < \hbox{\it epsabs} + \hbox{\it epsrel\/}\, |x_i|
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-|dx_i| < epsabs + epsrel |x_i|
-@end example
-
-@end ifinfo
-@noindent
-for each component of @var{x} and returns @code{GSL_CONTINUE} otherwise.
-@end deftypefun
-
-@cindex residual, in nonlinear systems of equations
-@deftypefun int gsl_multifit_test_gradient (const gsl_vector * @var{g}, double @var{epsabs})
-This function tests the residual gradient @var{g} against the absolute
-error bound @var{epsabs}.  Mathematically, the gradient should be
-exactly zero at the minimum. The test returns @code{GSL_SUCCESS} if the
-following condition is achieved,
-@tex
-\beforedisplay
-$$
-\sum_i |g_i| < \hbox{\it epsabs}
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-\sum_i |g_i| < epsabs
-@end example
-
-@end ifinfo
-@noindent
-and returns @code{GSL_CONTINUE} otherwise.  This criterion is suitable
-for situations where the precise location of the minimum, @math{x},
-is unimportant provided a value can be found where the gradient is small
-enough.
-@end deftypefun
-
-
-@deftypefun int gsl_multifit_gradient (const gsl_matrix * @var{J}, const gsl_vector * @var{f}, gsl_vector * @var{g})
-This function computes the gradient @var{g} of @math{\Phi(x) = (1/2)
-||f(x)||^2} from the Jacobian matrix @math{J} and the function values
-@var{f}, using the formula @math{g = J^T f}.
-@end deftypefun
-
-@node High Level Driver
-@section High Level Driver
-
-These routines provide a high level wrapper that combine the iteration
-and convergence testing for easy use.
-
-@deftypefun int gsl_multifit_fsolver_driver (gsl_multifit_fsolver * @var{s}, const size_t @var{maxiter}, const double @var{epsabs}, const double @var{epsrel})
-This function iterates the solver @var{s} for a maximum of @var{maxiter}
-iterations. After each iteration, the system is tested for convergence
-using @code{gsl_multifit_test_delta} with the error tolerances @var{epsabs}
-and @var{epsrel}.
-@end deftypefun
-
-@deftypefun int gsl_multifit_fdfsolver_driver (gsl_multifit_fdfsolver * @var{s}, const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
-@deftypefunx int gsl_multifit_fdfridge_driver (gsl_multifit_fdfridge * @var{s}, const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
-These functions iterate the solver @var{s} for a maximum of @var{maxiter}
-iterations. After each iteration, the system is tested for convergence
-with the error tolerances @var{xtol}, @var{gtol} and @var{ftol}.
-Upon successful convergence,
-the function returns @code{GSL_SUCCESS} and sets @var{info} to
-the reason for convergence (see @code{gsl_multifit_fdfsolver_test}).
-Otherwise, the function returns @code{GSL_EMAXITER} indicating
-the system did not converge after @var{maxiter} iterations.
-@end deftypefun
-
-@node Minimization Algorithms using Derivatives
-@section Minimization Algorithms using Derivatives
-
-The minimization algorithms described in this section make use of both
-the function and its derivative.  They require an initial guess for the
-location of the minimum. There is no absolute guarantee of
-convergence---the function must be suitable for this technique and the
-initial guess must be sufficiently close to the minimum for it to work.
-
-@comment ============================================================
-@cindex Levenberg-Marquardt algorithms
-
-@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmsder
-@cindex LMDER algorithm
-@cindex MINPACK, minimization algorithms
-
-This is a robust and efficient version of the Levenberg-Marquardt
-algorithm as implemented in the scaled @sc{lmder} routine in
-@sc{minpack}.  Minpack was written by Jorge J. Mor@'e, Burton S. Garbow
-and Kenneth E. Hillstrom.
-
-The algorithm uses a generalized trust region to keep each step under
-control.  In order to be accepted a proposed new position @math{x'} must
-satisfy the condition @math{|D (x' - x)| < \Delta}, where @math{D} is a
-diagonal scaling matrix and @math{\Delta} is the size of the trust
-region.  The components of @math{D} are computed internally, using the
-column norms of the Jacobian to estimate the sensitivity of the residual
-to each component of @math{x}.  This improves the behavior of the
-algorithm for badly scaled functions.
-
-On each iteration the algorithm attempts to minimize the linear system
-@math{|f + J \delta|} subject to the constraint @math{|D \delta| < \Delta}.
-The solution to this constrained linear system is found by solving
-the linear least squares system
-@tex
-\beforedisplay
-$$
-\left[
-\matrix{
-J \cr
-\sqrt{\mu} D
-}
-\right]
-\delta =
--
-\left[
-\matrix{
-f \cr
-0
-}
-\right]
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-[J; sqrt(mu) D] \delta = - [f; 0]
-@end example
-
-@end ifinfo
-where @math{\mu} is the Levenberg-Marquardt parameter. The above
-system is solved using a QR decomposition of @math{J}.
-
-The proposed step @math{\delta} is now tested by evaluating the
-function at the resulting point, @math{x'}.  If the step reduces the norm of the
-function sufficiently, and follows the predicted behavior of the
-function within the trust region, then it is accepted and the size of the
-trust region is increased.  If the proposed step fails to improve the
-solution, or differs significantly from the expected behavior within
-the trust region, then the size of the trust region is decreased and
-another trial step is computed.
-
-The algorithm also monitors the progress of the solution and returns an
-error if the changes in the solution are smaller than the machine
-precision.  The possible error codes are,
-
-@table @code
-@item GSL_ETOLF
-the decrease in the function falls below machine precision
-
-@item GSL_ETOLX
-the change in the position vector falls below machine precision
-
-@item GSL_ETOLG
-the norm of the gradient, relative to the norm of the function, falls
-below machine precision
-
-@item GSL_ENOPROG
-the routine has made 10 or more attempts to find a suitable trial step
-without success (but subsequent calls can be made to continue the
-search).@footnote{The return code @code{GSL_CONTINUE} was used for
-this case in versions prior to 1.14.}
-@end table
-
-@noindent
-These error codes indicate that further iterations will be unlikely to
-change the solution from its current value.  
-@end deffn
-
-@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmder
-
-This is an unscaled version of the @sc{lmder} algorithm.  The elements of the
-diagonal scaling matrix @math{D} are set to 1.  This algorithm may be
-useful in circumstances where the scaled version of @sc{lmder} converges too
-slowly, or the function is already scaled appropriately.
-@end deffn
-
-@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmniel
-
-This is a Levenberg-Marquardt solver based on a smoother updating
-procedure for the damping parameter @math{\mu} proposed by
-Nielsen, 1999. It does not use a trust region approach and only
-performs rudimentary scaling and is therefore not as robust as
-@code{lmsder}. However, on each iteration it solves the normal
-equation system to compute the next step:
-@tex
-\beforedisplay
-$$
-\left( J^T J + \mu I \right) \delta = - J^T f
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-(J^T J + \mu I) \delta = -J^T f
-@end example
-
-@end ifinfo
-which makes it a much more practical method for problems with a
-large number of residuals (@math{n >> p}), since only the
-@math{p}-by-@math{p} matrix @math{J^T J} is decomposed rather than
-the full @math{n}-by-@math{p} Jacobian. This makes a significant
-difference in efficiency when solving systems with large amounts
-of data. While not as robust as @code{lmsder}, this algorithm has
-proven effective on a wide class of problems.
-@end deffn
-
-@node Minimization Algorithms without Derivatives
-@section Minimization Algorithms without Derivatives
-
-There are no algorithms implemented in this section at the moment.
-
-@node Computing the covariance matrix of best fit parameters
-@section Computing the covariance matrix of best fit parameters
-@cindex best-fit parameters, covariance
-@cindex least squares, covariance of best-fit parameters
-@cindex covariance matrix, nonlinear fits
-
-@deftypefun int gsl_multifit_fdfsolver_jac (gsl_multifit_fdfsolver * @var{s}, gsl_matrix * @var{J})
-This function stores the @math{n}-by-@math{p} Jacobian matrix for the
-current iteration of the solver @var{s} into the output @var{J}.
-@end deftypefun
-
-@deftypefun int gsl_multifit_covar (const gsl_matrix * @var{J}, const double @var{epsrel}, gsl_matrix * @var{covar})
-This function computes the covariance matrix of best-fit parameters
-using the Jacobian matrix @var{J} and stores it in @var{covar}.
-The parameter @var{epsrel} is used to remove linear-dependent columns
-when @var{J} is rank deficient.
-
-The covariance matrix is given by,
-@tex
-\beforedisplay
-$$
-C = (J^T J)^{-1}
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-covar = (J^T J)^@{-1@}
-@end example
-
-@end ifinfo
-or in the weighted case,
-@tex
-\beforedisplay
-$$
-C = (J^T W J)^{-1}
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-covar = (J^T W J)^@{-1@}
-@end example
-
-@end ifinfo
-@noindent
-and is computed by QR decomposition of J with column-pivoting.  Any
-columns of @math{R} which satisfy 
-@tex
-\beforedisplay
-$$
-|R_{kk}| \leq epsrel |R_{11}|
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-|R_@{kk@}| <= epsrel |R_@{11@}|
-@end example
-
-@end ifinfo
-@noindent
-are considered linearly-dependent and are excluded from the covariance
-matrix (the corresponding rows and columns of the covariance matrix are
-set to zero).
-
-If the minimisation uses the weighted least-squares function
-@math{f_i = (Y(x, t_i) - y_i) / \sigma_i} then the covariance
-matrix above gives the statistical error on the best-fit parameters
-resulting from the Gaussian errors @math{\sigma_i} on 
-the underlying data @math{y_i}.  This can be verified from the relation 
-@math{\delta f = J \delta c} and the fact that the fluctuations in @math{f}
-from the data @math{y_i} are normalised by @math{\sigma_i} and 
-so satisfy @c{$\langle \delta f \delta f^T \rangle = I$}
-@math{<\delta f \delta f^T> = I}.
-
-For an unweighted least-squares function @math{f_i = (Y(x, t_i) -
-y_i)} the covariance matrix above should be multiplied by the variance
-of the residuals about the best-fit @math{\sigma^2 = \sum (y_i - Y(x,t_i))^2 / (n-p)}
-to give the variance-covariance
-matrix @math{\sigma^2 C}.  This estimates the statistical error on the
-best-fit parameters from the scatter of the underlying data.
-
-For more information about covariance matrices see @ref{Fitting Overview}.
-@end deftypefun
-
-@comment ============================================================
-
-@node Troubleshooting Nonlinear Least Squares
-@section Troubleshooting
-
-When developing a code to solve a nonlinear least squares problem,
-here are a few considerations to keep in mind.
-
-@enumerate
-
-@item
-The most common difficulty is the accurate implementation of the Jacobian
-matrix. If the analytic Jacobian is not properly provided to the
-solver, this can hinder and many times prevent convergence of the method.
-When developing a new nonlinear least squares code, it often helps
-to compare the program output with the internally computed finite
-difference Jacobian and the user supplied analytic Jacobian. If there
-is a large difference in coefficients, it is likely the analytic
-Jacobian is incorrectly implemented.
-
-@item
-If your code is having difficulty converging, the next thing to
-check is the starting point provided to the solver. The methods
-of this chapter are local methods, meaning if you provide a starting
-point far away from the true minimum, the method may converge to
-a local minimum or not converge at all. Sometimes it is possible
-to solve a linearized approximation to the nonlinear problem,
-and use the linear solution as the starting point to the nonlinear
-problem.
-
-@item
-If the various parameters of the coefficient vector @math{x}
-vary widely in magnitude, then the problem is said to be badly scaled.
-The methods of this chapter do attempt to automatically rescale
-the elements of @math{x} to have roughly the same order of magnitude,
-but in extreme cases this could still cause problems for convergence.
-In these cases it is recommended for the user to scale their
-parameter vector @math{x} so that each parameter spans roughly the
-same range, say @math{[-1,1]}. The solution vector can be backscaled
-to recover the original units of the problem.
-
-@end enumerate
-
-@node Example programs for Nonlinear Least-Squares Fitting
-@section Examples
-
-The following example program fits a weighted exponential model with
-background to experimental data, @math{Y = A \exp(-\lambda t) + b}. The
-first part of the program sets up the functions @code{expb_f} and
-@code{expb_df} to calculate the model and its Jacobian.  The appropriate
-fitting function is given by,
-@tex
-\beforedisplay
-$$
-f_i = (A \exp(-\lambda t_i) + b) - y_i
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-f_i = (A \exp(-\lambda t_i) + b) - y_i
-@end example
-
-@end ifinfo
-@noindent
-where we have chosen @math{t_i = i}.  The Jacobian matrix @math{J} is
-the derivative of these functions with respect to the three parameters
-(@math{A}, @math{\lambda}, @math{b}).  It is given by,
-@tex
-\beforedisplay
-$$
-J_{ij} = {\partial f_i \over \partial x_j}
-$$
-\afterdisplay
-@end tex
-@ifinfo
-
-@example
-J_@{ij@} = d f_i / d x_j
-@end example
-
-@end ifinfo
-@noindent
-where @math{x_0 = A}, @math{x_1 = \lambda} and @math{x_2 = b}. The
-weights are given by @math{w_i = 1/\sigma_i^2}.
-
-@example
-@verbatiminclude examples/expfit.c
-@end example
-
-@noindent
-The main part of the program sets up a Levenberg-Marquardt solver and
-some simulated random data. The data uses the known parameters
-(5.0,0.1,1.0) combined with Gaussian noise (standard deviation = 0.1)
-over a range of 40 timesteps. The initial guess for the parameters is
-chosen as (0.0, 1.0, 0.0).
-
-@example
-@verbatiminclude examples/nlfit.c
-@end example
-
-@noindent
-The iteration terminates when the relative change in x is smaller than
-@math{10^{-8}}, or when the magnitude of the gradient falls below
-@math{10^{-8}}.
-Here are the results of running the program:
-
-@smallexample
-summary from method 'lmsder'
-number of iterations: 8
-function evaluations: 11
-Jacobian evaluations: 9
-reason for stopping: small step size
-initial |f(x)| = 31.1919
-final   |f(x)| = 5.45418
-chisq/dof = 0.804002
-A      = 5.17379 +/- 0.27938
-lambda = 0.11104 +/- 0.00817
-b      = 1.05283 +/- 0.05365
-status = success
-@end smallexample
-
-@noindent
-The approximate values of the parameters are found correctly, and the
-chi-squared value indicates a good fit (the chi-squared per degree of
-freedom is approximately 1).  In this case the errors on the parameters
-can be estimated from the square roots of the diagonal elements of the
-covariance matrix.  
-
-If the chi-squared value shows a poor fit (i.e. @c{$\chi^2/(n-p) \gg 1$}
-@math{chi^2/dof >> 1}) then the error estimates obtained from the
-covariance matrix will be too small.  In the example program the error estimates
-are multiplied by @c{$\sqrt{\chi^2/(n-p)}$}
-@math{\sqrt@{\chi^2/dof@}} in this case, a common way of increasing the
-errors for a poor fit.  Note that a poor fit will result from the use
-an inappropriate model, and the scaled error estimates may then
-be outside the range of validity for Gaussian errors.
-
-@iftex
-@sp 1
-@center @image{fit-exp,3.4in}
-@end iftex
-
-@node References and Further Reading for Nonlinear Least-Squares Fitting
-@section References and Further Reading
-
-The @sc{minpack} algorithm is described in the following article,
-
-@itemize @w{}
-@item
-J.J. Mor@'e, @cite{The Levenberg-Marquardt Algorithm: Implementation and
-Theory}, Lecture Notes in Mathematics, v630 (1978), ed G. Watson.
-@end itemize
-
-@noindent
-The @code{lmniel} algorithm closely follows the following publications,
-
-@itemize @w{}
-@item
-H. B. Nielsen, ``Damping Parameter in Marquardt's Method'',
-IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-1999-05
-(1999).
-
-@item
-K. Madsen and H. B. Nielsen, ``Introduction to Optimization and Data
-Fitting'', IMM Department of Mathematical Modeling, DTU, 2010.
-@end itemize
-
-@noindent
-The following publications are also relevant to the algorithms described
-in this section,
-
-@itemize @w{}
-@item
-J. E. Dennis and R. B. Schnabel, Numerical Methods for Unconstrained
-Optimization and Nonlinear Equations, SIAM, 1996.
-
-@item 
-J.J. Mor@'e, B.S. Garbow, K.E. Hillstrom, ``Testing Unconstrained
-Optimization Software'', ACM Transactions on Mathematical Software, Vol
-7, No 1 (1981), p 17--41.
-
-@item 
-H. B. Nielsen, ``UCTP Test Problems for Unconstrained Optimization'',
-IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-2000-17
-(2000).
-@end itemize
-
diff --git a/ieee-utils/fp-win.c b/ieee-utils/fp-win.c
deleted file mode 100644
index e024eae..0000000
--- a/ieee-utils/fp-win.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/* fp-win.c
- * 
- * Author: Brian Gladman
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <float.h>
-
-#include <config.h>
-#include <gsl/gsl_ieee_utils.h>
-#include <gsl/gsl_errno.h>
-
-const char *fp_env_string = "round-to-nearest,double-precision,mask-all";
-
-int
-gsl_ieee_set_mode (int precision, int rounding, int exception_mask)
-{
-	unsigned int old, mode = _DN_SAVE, mask = _MCW_DN | _MCW_RC | _MCW_EM;
-
-	switch(precision)
-    {
-    case GSL_IEEE_SINGLE_PRECISION:		mode |= _PC_24; break;
-    case GSL_IEEE_EXTENDED_PRECISION:	mode |= _PC_64; break;
-    case GSL_IEEE_DOUBLE_PRECISION:
-    default:							mode |= _PC_53;
-	}
-#ifndef _M_AMD64
-	mask |= _MCW_PC;
-#endif
-
-	switch(rounding)
-    {
-    case GSL_IEEE_ROUND_DOWN:			mode |= _RC_DOWN; break;
-    case GSL_IEEE_ROUND_UP:				mode |= _RC_UP;   break;
-    case GSL_IEEE_ROUND_TO_ZERO:		mode |= _RC_CHOP; break;
-    case GSL_IEEE_ROUND_TO_NEAREST:
-    default:							mode |= _RC_NEAR;
-    }
-
-	if(exception_mask & GSL_IEEE_MASK_INVALID)
-		mode |= _EM_INVALID;
-	if(exception_mask & GSL_IEEE_MASK_DENORMALIZED)
-		mode |= _EM_DENORMAL;
-	if(exception_mask & GSL_IEEE_MASK_DIVISION_BY_ZERO)
-		mode |= _EM_ZERODIVIDE;
-	if(exception_mask & GSL_IEEE_MASK_OVERFLOW)
-		mode |= _EM_OVERFLOW;
-	if(exception_mask & GSL_IEEE_MASK_UNDERFLOW)
-		mode |= _EM_UNDERFLOW;
-	if(exception_mask & GSL_IEEE_TRAP_INEXACT)
-		mode &= ~_EM_INEXACT;
-	else
-		mode |= _EM_INEXACT;
-
-	_controlfp_s( &old, mode, mask);
-	return GSL_SUCCESS;
-}
-- 
2.10.0

From f82576d2ba7e2c915c5694935a7cb9137e0670a5 Mon Sep 17 00:00:00 2001
From: vitaut <victor.zverovich@gmail.com>
Date: Tue, 17 Nov 2015 10:16:47 -0800
Subject: [PATCH] Remove unused and nonportable includes

---
 matrix/test.c | 1 -
 vector/test.c | 1 -
 2 files changed, 2 deletions(-)

diff --git a/matrix/test.c b/matrix/test.c
index 9539ad6..fa3b82e 100644
--- a/matrix/test.c
+++ b/matrix/test.c
@@ -30,7 +30,6 @@
 
 #include <stdlib.h>
 #include <stdio.h>
-#include <unistd.h>
 #include <math.h>
 #include <gsl/gsl_math.h>
 #include <gsl/gsl_matrix.h>
diff --git a/vector/test.c b/vector/test.c
index 649ba9f..51e326d 100644
--- a/vector/test.c
+++ b/vector/test.c
@@ -30,7 +30,6 @@
 #endif
 
 #include <stdlib.h>
-#include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <gsl/gsl_math.h>
-- 
2.10.0

From e0dec660df236daa5c7ad76f4001cc331cf27a3c Mon Sep 17 00:00:00 2001
From: vitaut <victor.zverovich@gmail.com>
Date: Tue, 17 Nov 2015 09:55:33 -0800
Subject: [PATCH] Add fp-win32.c required to build GSL with MSVC

---
 ieee-utils/fp-win.c | 68 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 ieee-utils/fp.c     |  2 ++
 2 files changed, 70 insertions(+)
 create mode 100644 ieee-utils/fp-win.c

diff --git a/ieee-utils/fp-win.c b/ieee-utils/fp-win.c
new file mode 100644
index 0000000..fc1c874
--- /dev/null
+++ b/ieee-utils/fp-win.c
@@ -0,0 +1,68 @@
+/* fp-win.c
+ * 
+ * Author: Brian Gladman
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <float.h>
+
+#include <config.h>
+#include <gsl/gsl_ieee_utils.h>
+#include <gsl/gsl_errno.h>
+
+const char *fp_env_string = "round-to-nearest,double-precision,mask-all";
+
+int
+gsl_ieee_set_mode (int precision, int rounding, int exception_mask)
+{
+	unsigned int old, mode = _DN_SAVE, mask = _MCW_DN | _MCW_RC | _MCW_EM;
+
+	switch(precision)
+    {
+    case GSL_IEEE_SINGLE_PRECISION:		mode |= _PC_24; break;
+    case GSL_IEEE_EXTENDED_PRECISION:	mode |= _PC_64; break;
+    case GSL_IEEE_DOUBLE_PRECISION:
+    default:							mode |= _PC_53;
+	}
+	mask |= _MCW_PC;
+
+	switch(rounding)
+    {
+    case GSL_IEEE_ROUND_DOWN:			mode |= _RC_DOWN; break;
+    case GSL_IEEE_ROUND_UP:				mode |= _RC_UP;   break;
+    case GSL_IEEE_ROUND_TO_ZERO:		mode |= _RC_CHOP; break;
+    case GSL_IEEE_ROUND_TO_NEAREST:
+    default:							mode |= _RC_NEAR;
+    }
+
+	if(exception_mask & GSL_IEEE_MASK_INVALID)
+		mode |= _EM_INVALID;
+	if(exception_mask & GSL_IEEE_MASK_DENORMALIZED)
+		mode |= _EM_DENORMAL;
+	if(exception_mask & GSL_IEEE_MASK_DIVISION_BY_ZERO)
+		mode |= _EM_ZERODIVIDE;
+	if(exception_mask & GSL_IEEE_MASK_OVERFLOW)
+		mode |= _EM_OVERFLOW;
+	if(exception_mask & GSL_IEEE_MASK_UNDERFLOW)
+		mode |= _EM_UNDERFLOW;
+	if(exception_mask & GSL_IEEE_TRAP_INEXACT)
+		mode &= ~_EM_INEXACT;
+	else
+		mode |= _EM_INEXACT;
+
+	_controlfp_s( &old, mode, mask);
+	return GSL_SUCCESS;
+}
diff --git a/ieee-utils/fp.c b/ieee-utils/fp.c
index 445a14f..b6ae5af 100644
--- a/ieee-utils/fp.c
+++ b/ieee-utils/fp.c
@@ -45,6 +45,8 @@
 #endif
 #elif HAVE_DECL_FEENABLEEXCEPT || HAVE_DECL_FESETTRAPENABLE
 #include "fp-gnuc99.c"
+#elif _MSC_VER
+#include "fp-win.c"
 #else
 #include "fp-unknown.c" 
 #endif
-- 
2.10.0

From fe3d6e2393139931a9d77d03c00972c63d2adb51 Mon Sep 17 00:00:00 2001
From: vitaut <victor.zverovich@gmail.com>
Date: Tue, 17 Nov 2015 10:03:45 -0800
Subject: [PATCH] Use "static inline" instead of "inline" to prevent link
 errors in MSVC

---
 gsl_inline.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gsl_inline.h b/gsl_inline.h
index 2172201..8a00378 100644
--- a/gsl_inline.h
+++ b/gsl_inline.h
@@ -49,7 +49,7 @@
 #ifdef HAVE_INLINE
 #  if defined(__GNUC_STDC_INLINE__) || defined(GSL_C99_INLINE) || defined(HAVE_C99_INLINE)
 #    define INLINE_DECL inline  /* use C99 inline */
-#    define INLINE_FUN inline
+#    define INLINE_FUN static inline
 #  else
 #    define INLINE_DECL         /* use GNU extern inline */
 #    define INLINE_FUN extern inline
-- 
2.10.0

From 2a7dd4555f1d6edfff83fa6057ac496ffe4a0bb9 Mon Sep 17 00:00:00 2001
From: Filipe Brandao <fdabrandao@gmail.com>
Date: Sat, 17 Sep 2016 19:39:30 -0400
Subject: [PATCH] Remove unused and nonportable include

---
 spmatrix/test.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/spmatrix/test.c b/spmatrix/test.c
index 64cc762..d39f267 100644
--- a/spmatrix/test.c
+++ b/spmatrix/test.c
@@ -20,7 +20,6 @@
 #include <config.h>
 #include <stdlib.h>
 #include <math.h>
-#include <unistd.h>
 
 #include <gsl/gsl_math.h>
 #include <gsl/gsl_errno.h>
-- 
2.10.0

From d389f003a27b9d2f9ff3005e6afbb8ef9f48b736 Mon Sep 17 00:00:00 2001
From: Filipe Brandao <fdabrandao@gmail.com>
Date: Sat, 17 Sep 2016 19:44:54 -0400
Subject: [PATCH] Replace log2(x) by log(x)/log(2)

since MSVC does not provide log2
---
 linalg/qrpt.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linalg/qrpt.c b/linalg/qrpt.c
index 944f6e9..d75a671 100644
--- a/linalg/qrpt.c
+++ b/linalg/qrpt.c
@@ -599,7 +599,7 @@ gsl_linalg_QRPT_rank (const gsl_matrix * QR, const double tol)
 
       gsl_vector_minmax(&diag.vector, &min, &max);
       absmax = GSL_MAX(fabs(min), fabs(max));
-      ee = (int) log2(absmax);
+      ee = (int) (log(absmax) / log(2.0));
 
       eps = 20.0 * (M + N) * pow(2.0, (double) ee) * GSL_DBL_EPSILON;
     }
-- 
2.10.0

From c7211a268cc91b42dc1d573a9b1804f85c069f37 Mon Sep 17 00:00:00 2001
From: Victor Zverovich <victor.zverovich@gmail.com>
Date: Fri, 19 Aug 2016 11:56:19 -0700
Subject: [PATCH] Fix assertion failure on amd64 when compiled with MSVC (#7)

---
 ieee-utils/fp-win.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/ieee-utils/fp-win.c b/ieee-utils/fp-win.c
index fc1c874..e024eae 100644
--- a/ieee-utils/fp-win.c
+++ b/ieee-utils/fp-win.c
@@ -37,7 +37,9 @@ gsl_ieee_set_mode (int precision, int rounding, int exception_mask)
     case GSL_IEEE_DOUBLE_PRECISION:
     default:							mode |= _PC_53;
 	}
+#ifndef _M_AMD64
 	mask |= _MCW_PC;
+#endif
 
 	switch(rounding)
     {
-- 
2.10.0

From cd8bc800c2c0e8f7875649db073e600b5c1071a9 Mon Sep 17 00:00:00 2001
From: Filipe Brandao <fdabrandao@gmail.com>
Date: Thu, 22 Sep 2016 09:39:41 -0400
Subject: [PATCH] Add cross-platform format macro F_ZU for size_t (#9)

---
 configure.ac | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/configure.ac b/configure.ac
index b962d6d..8fe7287 100644
--- a/configure.ac
+++ b/configure.ac
@@ -575,6 +575,15 @@ AH_BOTTOM([#if defined(GSL_RANGE_CHECK_OFF) || !defined(GSL_RANGE_CHECK)
 AH_BOTTOM([#define RETURN_IF_NULL(x) if (!x) { return ; }
 ])
 
+AH_BOTTOM([/* Microsoft Visual C does not support "%zu" */
+#ifdef _WIN64
+#define F_ZU "%llu"
+#elif _WIN32
+#define F_ZU "%lu"
+#else
+#define F_ZU "%zu"
+#endif])
+
 AH_VERBATIM([GSL_DISABLE_DEPRECATED],
 [/* Disable deprecated functions and enums while building */
 #define GSL_DISABLE_DEPRECATED 1])
-- 
2.10.0

From 32ea6f3e431163fd680410fa59d19d1b48192c6d Mon Sep 17 00:00:00 2001
From: Filipe Brandao <fdabrandao@gmail.com>
Date: Thu, 22 Sep 2016 09:42:18 -0400
Subject: [PATCH] Replace all occurrences of %zu by F_ZU in order to fix #9

find . -name "*.c" -exec sed -i 's/"%zu"/F_ZU/g' {} \;
find . -name "*.c" -exec sed -i 's/"%zu/F_ZU"/g' {} \;
find . -name "*.c" -exec sed -i 's/%zu"/"F_ZU/g' {} \;
find . -name "*.c" -exec sed -i 's/%zu/"F_ZU"/g' {} \;
---
 doc/examples/block.c                  |  2 +-
 doc/examples/fftmr.c                  |  2 +-
 doc/examples/integration.c            |  2 +-
 doc/examples/nlfit.c                  |  8 ++---
 doc/examples/nlfit2.c                 |  8 ++---
 doc/examples/poisson.c                |  2 +-
 doc/examples/sortsmall.c              |  4 +--
 doc/examples/spmatrix.c               | 10 +++---
 doc/examples/sum.c                    |  4 +--
 doc/examples/vectorview.c             |  2 +-
 linalg/test.c                         |  2 +-
 linalg/test_cholesky.c                |  6 ++--
 multifit/test_bard.c                  |  2 +-
 multifit/test_beale.c                 |  2 +-
 multifit/test_box.c                   |  2 +-
 multifit/test_boxbod.c                |  2 +-
 multifit/test_brown1.c                |  2 +-
 multifit/test_brown2.c                |  2 +-
 multifit/test_brown3.c                |  2 +-
 multifit/test_eckerle.c               |  2 +-
 multifit/test_enso.c                  |  2 +-
 multifit/test_exp1.c                  |  2 +-
 multifit/test_filip.c                 |  4 +--
 multifit/test_gaussian.c              |  2 +-
 multifit/test_hahn1.c                 |  2 +-
 multifit/test_helical.c               |  2 +-
 multifit/test_jennrich.c              |  2 +-
 multifit/test_kirby2.c                |  2 +-
 multifit/test_kowalik.c               |  2 +-
 multifit/test_lin1.c                  |  2 +-
 multifit/test_longley.c               |  4 +--
 multifit/test_meyer.c                 |  2 +-
 multifit/test_meyerscal.c             |  2 +-
 multifit/test_nonlinear.c             |  4 +--
 multifit/test_pontius.c               |  4 +--
 multifit/test_powell1.c               |  2 +-
 multifit/test_powell2.c               |  2 +-
 multifit/test_powell3.c               |  2 +-
 multifit/test_rat42.c                 |  2 +-
 multifit/test_rat43.c                 |  2 +-
 multifit/test_reg.c                   | 20 ++++++------
 multifit/test_rosenbrock.c            |  2 +-
 multifit/test_rosenbrocke.c           |  2 +-
 multifit/test_roth.c                  |  2 +-
 multifit/test_shaw.c                  | 10 +++---
 multifit/test_thurber.c               |  2 +-
 multifit/test_vardim.c                |  2 +-
 multifit/test_watson.c                |  2 +-
 multifit/test_wnlin.c                 |  2 +-
 multifit/test_wood.c                  |  2 +-
 multifit_nlinear/test_bard.c          |  2 +-
 multifit_nlinear/test_beale.c         |  2 +-
 multifit_nlinear/test_biggs.c         |  2 +-
 multifit_nlinear/test_boxbod.c        |  2 +-
 multifit_nlinear/test_brown1.c        |  2 +-
 multifit_nlinear/test_brown2.c        |  2 +-
 multifit_nlinear/test_brown3.c        |  2 +-
 multifit_nlinear/test_eckerle.c       |  2 +-
 multifit_nlinear/test_enso.c          |  2 +-
 multifit_nlinear/test_exp1.c          |  2 +-
 multifit_nlinear/test_gaussian.c      |  2 +-
 multifit_nlinear/test_hahn1.c         |  2 +-
 multifit_nlinear/test_helical.c       |  2 +-
 multifit_nlinear/test_jennrich.c      |  2 +-
 multifit_nlinear/test_kirby2.c        |  2 +-
 multifit_nlinear/test_kowalik.c       |  2 +-
 multifit_nlinear/test_lin1.c          |  2 +-
 multifit_nlinear/test_meyer.c         |  2 +-
 multifit_nlinear/test_meyerscal.c     |  2 +-
 multifit_nlinear/test_powell1.c       |  2 +-
 multifit_nlinear/test_powell2.c       |  2 +-
 multifit_nlinear/test_powell3.c       |  2 +-
 multifit_nlinear/test_rat42.c         |  2 +-
 multifit_nlinear/test_rat43.c         |  2 +-
 multifit_nlinear/test_rosenbrock.c    |  2 +-
 multifit_nlinear/test_rosenbrocke.c   |  2 +-
 multifit_nlinear/test_roth.c          |  2 +-
 multifit_nlinear/test_thurber.c       |  2 +-
 multifit_nlinear/test_vardim.c        |  2 +-
 multifit_nlinear/test_watson.c        |  2 +-
 multifit_nlinear/test_wnlin.c         |  2 +-
 multifit_nlinear/test_wood.c          |  2 +-
 multilarge/test.c                     | 16 +++++-----
 multilarge_nlinear/test_bard.c        |  2 +-
 multilarge_nlinear/test_beale.c       |  2 +-
 multilarge_nlinear/test_boxbod.c      |  2 +-
 multilarge_nlinear/test_brown1.c      |  2 +-
 multilarge_nlinear/test_brown2.c      |  2 +-
 multilarge_nlinear/test_brown3.c      |  2 +-
 multilarge_nlinear/test_eckerle.c     |  2 +-
 multilarge_nlinear/test_enso.c        |  2 +-
 multilarge_nlinear/test_exp1.c        |  2 +-
 multilarge_nlinear/test_gaussian.c    |  2 +-
 multilarge_nlinear/test_hahn1.c       |  2 +-
 multilarge_nlinear/test_helical.c     |  2 +-
 multilarge_nlinear/test_jennrich.c    |  2 +-
 multilarge_nlinear/test_kirby2.c      |  2 +-
 multilarge_nlinear/test_kowalik.c     |  2 +-
 multilarge_nlinear/test_lin1.c        |  2 +-
 multilarge_nlinear/test_meyer.c       |  2 +-
 multilarge_nlinear/test_meyerscal.c   |  2 +-
 multilarge_nlinear/test_powell1.c     |  2 +-
 multilarge_nlinear/test_powell2.c     |  2 +-
 multilarge_nlinear/test_powell3.c     |  2 +-
 multilarge_nlinear/test_rat42.c       |  2 +-
 multilarge_nlinear/test_rat43.c       |  2 +-
 multilarge_nlinear/test_rosenbrock.c  |  2 +-
 multilarge_nlinear/test_rosenbrocke.c |  2 +-
 multilarge_nlinear/test_roth.c        |  2 +-
 multilarge_nlinear/test_thurber.c     |  2 +-
 multilarge_nlinear/test_vardim.c      |  2 +-
 multilarge_nlinear/test_watson.c      |  2 +-
 multilarge_nlinear/test_wnlin.c       |  2 +-
 multilarge_nlinear/test_wood.c        |  2 +-
 rstat/test.c                          | 12 ++++----
 spblas/test.c                         |  2 +-
 specfunc/test_legendre.c              | 34 ++++++++++----------
 splinalg/test.c                       | 14 ++++-----
 spmatrix/spio.c                       | 12 ++++----
 spmatrix/test.c                       | 58 +++++++++++++++++------------------
 120 files changed, 218 insertions(+), 218 deletions(-)

diff --git a/doc/examples/block.c b/doc/examples/block.c
index ca6e80e..40e2b87 100644
--- a/doc/examples/block.c
+++ b/doc/examples/block.c
@@ -6,7 +6,7 @@ main (void)
 {
   gsl_block * b = gsl_block_alloc (100);
   
-  printf ("length of block = %zu\n", b->size);
+  printf ("length of block = "F_ZU"\n", b->size);
   printf ("block data address = %p\n", b->data);
 
   gsl_block_free (b);
diff --git a/doc/examples/fftmr.c b/doc/examples/fftmr.c
index b12dc76..0e2da4f 100644
--- a/doc/examples/fftmr.c
+++ b/doc/examples/fftmr.c
@@ -41,7 +41,7 @@ main (void)
 
   for (i = 0; i < (int) wavetable->nf; i++)
     {
-       printf ("# factor %d: %zu\n", i, 
+       printf ("# factor %d: "F_ZU"\n", i, 
                wavetable->factor[i]);
     }
 
diff --git a/doc/examples/integration.c b/doc/examples/integration.c
index 79dd1c3..a3d5097 100644
--- a/doc/examples/integration.c
+++ b/doc/examples/integration.c
@@ -29,7 +29,7 @@ main (void)
   printf ("exact result    = % .18f\n", expected);
   printf ("estimated error = % .18f\n", error);
   printf ("actual error    = % .18f\n", result - expected);
-  printf ("intervals       = %zu\n", w->size);
+  printf ("intervals       = "F_ZU"\n", w->size);
 
   gsl_integration_workspace_free (w);
 
diff --git a/doc/examples/nlfit.c b/doc/examples/nlfit.c
index 370ad8f..519bf08 100644
--- a/doc/examples/nlfit.c
+++ b/doc/examples/nlfit.c
@@ -134,7 +134,7 @@ main (void)
 
       weights[i] = 1.0 / (si * si);
       y[i] = yi + dy;
-      printf ("data: %zu %g %g\n", i, y[i], si);
+      printf ("data: "F_ZU" %g %g\n", i, y[i], si);
     };
 
   /* allocate workspace with default parameters */
@@ -164,10 +164,10 @@ main (void)
   fprintf(stderr, "summary from method '%s/%s'\n",
           gsl_multifit_nlinear_name(w),
           gsl_multifit_nlinear_trs_name(w));
-  fprintf(stderr, "number of iterations: %zu\n",
+  fprintf(stderr, "number of iterations: "F_ZU"\n",
           gsl_multifit_nlinear_niter(w));
-  fprintf(stderr, "function evaluations: %zu\n", fdf.nevalf);
-  fprintf(stderr, "Jacobian evaluations: %zu\n", fdf.nevaldf);
+  fprintf(stderr, "function evaluations: "F_ZU"\n", fdf.nevalf);
+  fprintf(stderr, "Jacobian evaluations: "F_ZU"\n", fdf.nevaldf);
   fprintf(stderr, "reason for stopping: %s\n",
           (info == 1) ? "small step size" : "small gradient");
   fprintf(stderr, "initial |f(x)| = %f\n", sqrt(chisq0));
diff --git a/doc/examples/nlfit2.c b/doc/examples/nlfit2.c
index f9ff235..96a85ec 100644
--- a/doc/examples/nlfit2.c
+++ b/doc/examples/nlfit2.c
@@ -90,10 +90,10 @@ solve_system(gsl_vector *x0, gsl_multifit_nlinear_fdf *fdf,
 
   /* print summary */
 
-  fprintf(stderr, "NITER         = %zu\n", gsl_multifit_nlinear_niter(work));
-  fprintf(stderr, "NFEV          = %zu\n", fdf->nevalf);
-  fprintf(stderr, "NJEV          = %zu\n", fdf->nevaldf);
-  fprintf(stderr, "NAEV          = %zu\n", fdf->nevalfvv);
+  fprintf(stderr, "NITER         = "F_ZU"\n", gsl_multifit_nlinear_niter(work));
+  fprintf(stderr, "NFEV          = "F_ZU"\n", fdf->nevalf);
+  fprintf(stderr, "NJEV          = "F_ZU"\n", fdf->nevaldf);
+  fprintf(stderr, "NAEV          = "F_ZU"\n", fdf->nevalfvv);
   fprintf(stderr, "initial cost  = %.12e\n", chisq0);
   fprintf(stderr, "final cost    = %.12e\n", chisq);
   fprintf(stderr, "final x       = (%.12e, %.12e)\n",
diff --git a/doc/examples/poisson.c b/doc/examples/poisson.c
index 5d9ba81..063db2e 100644
--- a/doc/examples/poisson.c
+++ b/doc/examples/poisson.c
@@ -72,7 +72,7 @@ main()
 
         /* print out residual norm ||A*u - f|| */
         residual = gsl_splinalg_itersolve_normr(work);
-        fprintf(stderr, "iter %zu residual = %.12e\n", iter, residual);
+        fprintf(stderr, "iter "F_ZU" residual = %.12e\n", iter, residual);
 
         if (status == GSL_SUCCESS)
           fprintf(stderr, "Converged\n");
diff --git a/doc/examples/sortsmall.c b/doc/examples/sortsmall.c
index d460ad4..9ace55c 100644
--- a/doc/examples/sortsmall.c
+++ b/doc/examples/sortsmall.c
@@ -24,11 +24,11 @@ main (void)
 
   gsl_sort_smallest (small, k, x, 1, N);
 
-  printf ("%zu smallest values from %zu\n", k, N);
+  printf (F_ZU" smallest values from "F_ZU"\n", k, N);
 
   for (i = 0; i < k; i++)
     {
-      printf ("%zu: %.18f\n", i, small[i]);
+      printf (F_ZU": %.18f\n", i, small[i]);
     }
 
   free (x);
diff --git a/doc/examples/spmatrix.c b/doc/examples/spmatrix.c
index f2a0f17..1cb8c95 100644
--- a/doc/examples/spmatrix.c
+++ b/doc/examples/spmatrix.c
@@ -23,7 +23,7 @@ main()
   printf("printing all matrix elements:\n");
   for (i = 0; i < 5; ++i)
     for (j = 0; j < 4; ++j)
-      printf("A(%zu,%zu) = %g\n", i, j,
+      printf("A("F_ZU","F_ZU") = %g\n", i, j,
              gsl_spmatrix_get(A, i, j));
 
   /* print out elements in triplet format */
@@ -36,12 +36,12 @@ main()
   printf("matrix in compressed column format:\n");
   printf("i = [ ");
   for (i = 0; i < B->nz; ++i)
-    printf("%zu, ", B->i[i]);
+    printf(F_ZU", ", B->i[i]);
   printf("]\n");
 
   printf("p = [ ");
   for (i = 0; i < B->size2 + 1; ++i)
-    printf("%zu, ", B->p[i]);
+    printf(F_ZU", ", B->p[i]);
   printf("]\n");
 
   printf("d = [ ");
@@ -55,12 +55,12 @@ main()
   printf("matrix in compressed row format:\n");
   printf("i = [ ");
   for (i = 0; i < C->nz; ++i)
-    printf("%zu, ", C->i[i]);
+    printf(F_ZU", ", C->i[i]);
   printf("]\n");
 
   printf("p = [ ");
   for (i = 0; i < C->size1 + 1; ++i)
-    printf("%zu, ", C->p[i]);
+    printf(F_ZU", ", C->p[i]);
   printf("]\n");
 
   printf("d = [ ");
diff --git a/doc/examples/sum.c b/doc/examples/sum.c
index 65dacc9..aa04c4f 100644
--- a/doc/examples/sum.c
+++ b/doc/examples/sum.c
@@ -31,11 +31,11 @@ main (void)
   printf ("term-by-term sum = % .16f using %d terms\n", 
           sum, N);
 
-  printf ("term-by-term sum = % .16f using %zu terms\n", 
+  printf ("term-by-term sum = % .16f using "F_ZU" terms\n", 
           w->sum_plain, w->terms_used);
 
   printf ("exact value      = % .16f\n", zeta_2);
-  printf ("accelerated sum  = % .16f using %zu terms\n", 
+  printf ("accelerated sum  = % .16f using "F_ZU" terms\n", 
           sum_accel, w->terms_used);
 
   printf ("estimated error  = % .16f\n", err);
diff --git a/doc/examples/vectorview.c b/doc/examples/vectorview.c
index 625f146..97d646f 100644
--- a/doc/examples/vectorview.c
+++ b/doc/examples/vectorview.c
@@ -21,7 +21,7 @@ main (void)
 
       d = gsl_blas_dnrm2 (&column.vector);
 
-      printf ("matrix column %zu, norm = %g\n", j, d);
+      printf ("matrix column "F_ZU", norm = %g\n", j, d);
     }
 
   gsl_matrix_free (m);
diff --git a/linalg/test.c b/linalg/test.c
index d56a15d..ed4349e 100644
--- a/linalg/test.c
+++ b/linalg/test.c
@@ -4706,7 +4706,7 @@ test_tri_invert2(CBLAS_UPLO_t Uplo, CBLAS_DIAG_t Diag, gsl_rng * r, const double
               double Bij = gsl_matrix_get(B, i, j);
               double expected = (i == j) ? 1.0 : 0.0;
 
-              gsl_test_rel(Bij, expected, tol, "tri_invert N=%zu %s %s",
+              gsl_test_rel(Bij, expected, tol, "tri_invert N="F_ZU" %s %s",
                            n,
                            (Uplo == CblasUpper) ? "Upper" : "Lower",
                            (Diag == CblasNonUnit) ? "NonUnit" : "Unit");
diff --git a/linalg/test_cholesky.c b/linalg/test_cholesky.c
index 8c9913e..1de232a 100644
--- a/linalg/test_cholesky.c
+++ b/linalg/test_cholesky.c
@@ -349,7 +349,7 @@ test_mcholesky_decomp_eps(const int posdef, const int scale, const gsl_matrix *
       /* ||E|| should be 0 */
       double norm = gsl_blas_dnrm2(E);
       s = norm != 0.0;
-      gsl_test(s, "%s: (%zu,%zu): ||E|| = %.12e",
+      gsl_test(s, "%s: ("F_ZU","F_ZU"): ||E|| = %.12e",
                desc, N, N, norm);
 
       /* check that D is decreasing */
@@ -363,7 +363,7 @@ test_mcholesky_decomp_eps(const int posdef, const int scale, const gsl_matrix *
             s = 1;
         }
 
-      gsl_test(s, "%s: (%zu,%zu): D is not decreasing",
+      gsl_test(s, "%s: ("F_ZU","F_ZU"): D is not decreasing",
                desc, N, N);
     }
   
@@ -687,7 +687,7 @@ test_pcholesky_decomp_eps(const int scale, const gsl_matrix * m,
         s = 1;
     }
 
-  gsl_test(s, "%s: (%zu,%zu): D is not decreasing",
+  gsl_test(s, "%s: ("F_ZU","F_ZU"): D is not decreasing",
            desc, N, N);
   
   /* compute L and LT */
diff --git a/multifit/test_bard.c b/multifit/test_bard.c
index 82c5770..c8c92f8 100644
--- a/multifit/test_bard.c
+++ b/multifit/test_bard.c
@@ -48,7 +48,7 @@ bard_checksol(const double x[], const double sumsq,
       if (!gsl_finite(bard_x[i]))
         continue;
 
-      gsl_test_rel(x[i], bard_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], bard_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_beale.c b/multifit/test_beale.c
index bfd2ed5..ca42870 100644
--- a/multifit/test_beale.c
+++ b/multifit/test_beale.c
@@ -22,7 +22,7 @@ beale_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < beale_P; ++i)
     {
-      gsl_test_rel(x[i], beale_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], beale_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_box.c b/multifit/test_box.c
index d742ed0..a309846 100644
--- a/multifit/test_box.c
+++ b/multifit/test_box.c
@@ -20,7 +20,7 @@ box_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < box_P; ++i)
     {
-      gsl_test_rel(x[i], box_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], box_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_boxbod.c b/multifit/test_boxbod.c
index 0ad9e0f..0fcd2ab 100644
--- a/multifit/test_boxbod.c
+++ b/multifit/test_boxbod.c
@@ -30,7 +30,7 @@ boxbod_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < boxbod_P; ++i)
     {
-      gsl_test_rel(x[i], boxbod_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], boxbod_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_brown1.c b/multifit/test_brown1.c
index a42ae49..88b9d86 100644
--- a/multifit/test_brown1.c
+++ b/multifit/test_brown1.c
@@ -22,7 +22,7 @@ brown1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < brown1_P; ++i)
     {
-      gsl_test_rel(x[i], brown1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], brown1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_brown2.c b/multifit/test_brown2.c
index 7b46a24..bb1aab0 100644
--- a/multifit/test_brown2.c
+++ b/multifit/test_brown2.c
@@ -44,7 +44,7 @@ brown2_checksol(const double x[], const double sumsq,
 
   for (i = 1; i < brown2_P - 1; ++i)
     {
-      gsl_test_rel(x[i], alpha, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], alpha, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 
diff --git a/multifit/test_brown3.c b/multifit/test_brown3.c
index d9eceb7..a4d5f79 100644
--- a/multifit/test_brown3.c
+++ b/multifit/test_brown3.c
@@ -20,7 +20,7 @@ brown3_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < brown3_P; ++i)
     {
-      gsl_test_rel(x[i], brown3_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], brown3_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_eckerle.c b/multifit/test_eckerle.c
index d81cc9e..278cf79 100644
--- a/multifit/test_eckerle.c
+++ b/multifit/test_eckerle.c
@@ -44,7 +44,7 @@ eckerle_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < eckerle_P; ++i)
     {
-      gsl_test_rel(x[i], eckerle_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], eckerle_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_enso.c b/multifit/test_enso.c
index 70956d1..4f11bcf 100644
--- a/multifit/test_enso.c
+++ b/multifit/test_enso.c
@@ -208,7 +208,7 @@ enso_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < enso_P; ++i)
     {
-      gsl_test_rel(x[i], enso_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], enso_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_exp1.c b/multifit/test_exp1.c
index 211c675..e676247 100644
--- a/multifit/test_exp1.c
+++ b/multifit/test_exp1.c
@@ -32,7 +32,7 @@ exp1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < exp1_P; ++i)
     {
-      gsl_test_rel(x[i], exp1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], exp1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_filip.c b/multifit/test_filip.c
index c98c53b..54001b6 100644
--- a/multifit/test_filip.c
+++ b/multifit/test_filip.c
@@ -45,14 +45,14 @@ test_filip_results(const char *str,
       gsl_test_rel (gsl_vector_get(c,i),
                     gsl_vector_get(expected_c, i),
                     1.0e-7,
-                    "%s c[%zu]", str, i) ;
+                    "%s c["F_ZU"]", str, i) ;
 
       if (cov_diag && expected_sd)
         {
           gsl_test_rel (sqrt(gsl_vector_get(cov_diag, i)),
                         gsl_vector_get(expected_sd, i),
                         1e-7,
-                        "%s cov[%zu,%zu]", str, i, i);
+                        "%s cov["F_ZU","F_ZU"]", str, i, i);
         }
     }
 
diff --git a/multifit/test_gaussian.c b/multifit/test_gaussian.c
index bd4389e..d462644 100644
--- a/multifit/test_gaussian.c
+++ b/multifit/test_gaussian.c
@@ -28,7 +28,7 @@ gaussian_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < gaussian_P; ++i)
     {
-      gsl_test_rel(x[i], gaussian_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], gaussian_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_hahn1.c b/multifit/test_hahn1.c
index 0cf84b1..5740665 100644
--- a/multifit/test_hahn1.c
+++ b/multifit/test_hahn1.c
@@ -516,7 +516,7 @@ hahn1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < hahn1_P; ++i)
     {
-      gsl_test_rel(x[i], hahn1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], hahn1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_helical.c b/multifit/test_helical.c
index 6bc3f39..fd44b34 100644
--- a/multifit/test_helical.c
+++ b/multifit/test_helical.c
@@ -21,7 +21,7 @@ helical_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < helical_P; ++i)
     {
-      gsl_test_rel(x[i], helical_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], helical_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_jennrich.c b/multifit/test_jennrich.c
index e129cfb..9f6198d 100644
--- a/multifit/test_jennrich.c
+++ b/multifit/test_jennrich.c
@@ -21,7 +21,7 @@ jennrich_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < jennrich_P; ++i)
     {
-      gsl_test_rel(x[i], jennrich_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], jennrich_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_kirby2.c b/multifit/test_kirby2.c
index 5c6fcb0..4d25ea3 100644
--- a/multifit/test_kirby2.c
+++ b/multifit/test_kirby2.c
@@ -342,7 +342,7 @@ kirby2_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < kirby2_P; ++i)
     {
-      gsl_test_rel(x[i], kirby2_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], kirby2_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_kowalik.c b/multifit/test_kowalik.c
index c68a645..df53861 100644
--- a/multifit/test_kowalik.c
+++ b/multifit/test_kowalik.c
@@ -57,7 +57,7 @@ kowalik_checksol(const double x[], const double sumsq,
       if (!gsl_finite(kowalik_x[i]))
         continue;
 
-      gsl_test_rel(x[i], kowalik_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], kowalik_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_lin1.c b/multifit/test_lin1.c
index 2c28ab8d..2b94a83 100644
--- a/multifit/test_lin1.c
+++ b/multifit/test_lin1.c
@@ -19,7 +19,7 @@ lin1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < lin1_P; ++i)
     {
-      gsl_test_rel(x[i], -1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], -1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_longley.c b/multifit/test_longley.c
index 8ac4856..111b8cf 100644
--- a/multifit/test_longley.c
+++ b/multifit/test_longley.c
@@ -37,14 +37,14 @@ test_longley_results(const char *str,
       gsl_test_rel (gsl_vector_get(c,i),
                     gsl_vector_get(expected_c, i),
                     1.0e-10,
-                    "%s c[%zu]", str, i) ;
+                    "%s c["F_ZU"]", str, i) ;
 
       if (cov_diag && expected_sd)
         {
           gsl_test_rel (sqrt(gsl_vector_get(cov_diag, i)),
                         gsl_vector_get(expected_sd, i),
                         1e-10,
-                        "%s cov[%zu,%zu]", str, i, i);
+                        "%s cov["F_ZU","F_ZU"]", str, i, i);
         }
     }
 
diff --git a/multifit/test_meyer.c b/multifit/test_meyer.c
index 2709c0f..f34cccb 100644
--- a/multifit/test_meyer.c
+++ b/multifit/test_meyer.c
@@ -28,7 +28,7 @@ meyer_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < meyer_P; ++i)
     {
-      gsl_test_rel(x[i], meyer_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], meyer_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_meyerscal.c b/multifit/test_meyerscal.c
index d75f3f9..48efa80 100644
--- a/multifit/test_meyerscal.c
+++ b/multifit/test_meyerscal.c
@@ -28,7 +28,7 @@ meyerscal_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < meyerscal_P; ++i)
     {
-      gsl_test_rel(x[i], meyerscal_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], meyerscal_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_nonlinear.c b/multifit/test_nonlinear.c
index d01f8f3..fcaf4e6 100644
--- a/multifit/test_nonlinear.c
+++ b/multifit/test_nonlinear.c
@@ -508,12 +508,12 @@ test_fdfridge(const gsl_multifit_fdfsolver_type * T, const double xtol,
 
         if (fabs(xi) < eps)
           {
-            gsl_test_abs(yi, xi, eps, "%s/%s ridge lambda=%g i=%zu",
+            gsl_test_abs(yi, xi, eps, "%s/%s ridge lambda=%g i="F_ZU,
                          sname, pname, lambda, i);
           }
         else
           {
-            gsl_test_rel(yi, xi, eps, "%s/%s ridge lambda=%g i=%zu",
+            gsl_test_rel(yi, xi, eps, "%s/%s ridge lambda=%g i="F_ZU,
                          sname, pname, lambda, i);
           }
       }
diff --git a/multifit/test_pontius.c b/multifit/test_pontius.c
index d327225..1351279 100644
--- a/multifit/test_pontius.c
+++ b/multifit/test_pontius.c
@@ -30,14 +30,14 @@ test_pontius_results(const char *str,
       gsl_test_rel (gsl_vector_get(c,i),
                     gsl_vector_get(expected_c, i),
                     1.0e-10,
-                    "%s c[%zu]", str, i) ;
+                    "%s c["F_ZU"]", str, i) ;
 
       if (cov_diag && expected_sd)
         {
           gsl_test_rel (sqrt(gsl_vector_get(cov_diag, i)),
                         gsl_vector_get(expected_sd, i),
                         1e-10,
-                        "%s cov[%zu,%zu]", str, i, i);
+                        "%s cov["F_ZU","F_ZU"]", str, i, i);
         }
     }
 
diff --git a/multifit/test_powell1.c b/multifit/test_powell1.c
index 572de3b..be0f0f4 100644
--- a/multifit/test_powell1.c
+++ b/multifit/test_powell1.c
@@ -19,7 +19,7 @@ powell1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell1_P; ++i)
     {
-      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_powell2.c b/multifit/test_powell2.c
index 05a4417..8b46b00 100644
--- a/multifit/test_powell2.c
+++ b/multifit/test_powell2.c
@@ -19,7 +19,7 @@ powell2_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell2_P; ++i)
     {
-      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_powell3.c b/multifit/test_powell3.c
index 7c83384..094ba9d 100644
--- a/multifit/test_powell3.c
+++ b/multifit/test_powell3.c
@@ -21,7 +21,7 @@ powell3_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell3_P; ++i)
     {
-      gsl_test_rel(x[i], powell3_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], powell3_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_rat42.c b/multifit/test_rat42.c
index 32a652b..99ef13a 100644
--- a/multifit/test_rat42.c
+++ b/multifit/test_rat42.c
@@ -33,7 +33,7 @@ rat42_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rat42_P; ++i)
     {
-      gsl_test_rel(x[i], rat42_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rat42_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_rat43.c b/multifit/test_rat43.c
index 2566926..aafa60e 100644
--- a/multifit/test_rat43.c
+++ b/multifit/test_rat43.c
@@ -33,7 +33,7 @@ rat43_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rat43_P; ++i)
     {
-      gsl_test_rel(x[i], rat43_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rat43_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_reg.c b/multifit/test_reg.c
index 9bd95f4..c29eed2 100644
--- a/multifit/test_reg.c
+++ b/multifit/test_reg.c
@@ -91,7 +91,7 @@ test_reg1(const gsl_matrix * X, const gsl_vector * y,
     }
 
   gsl_test_rel(rnorm*rnorm, chisq, tol,
-               "test_reg1: %s, lambda = 0, n=%zu p=%zu chisq", desc, n, p);
+               "test_reg1: %s, lambda = 0, n="F_ZU" p="F_ZU" chisq", desc, n, p);
 
   /* test c0 = c1 */
   for (j = 0; j < p; ++j)
@@ -99,7 +99,7 @@ test_reg1(const gsl_matrix * X, const gsl_vector * y,
       double c0j = gsl_vector_get(c0, j);
       double c1j = gsl_vector_get(c1, j);
 
-      gsl_test_rel(c1j, c0j, tol, "test_reg1: %s, lambda = 0, n=%zu p=%zu c0/c1",
+      gsl_test_rel(c1j, c0j, tol, "test_reg1: %s, lambda = 0, n="F_ZU" p="F_ZU" c0/c1",
                    desc, n, p);
     }
 
@@ -153,14 +153,14 @@ test_reg2(const double lambda, const gsl_matrix * X, const gsl_vector * y,
 
   /* test snorm = ||c1|| */
   snorm1 = gsl_blas_dnrm2(c1);
-  gsl_test_rel(snorm0, snorm1, tol, "test_reg2: %s, snorm lambda=%g n=%zu p=%zu",
+  gsl_test_rel(snorm0, snorm1, tol, "test_reg2: %s, snorm lambda=%g n="F_ZU" p="F_ZU,
                desc, lambda, n, p);
 
   /* test rnorm = ||y - X c1|| */
   gsl_vector_memcpy(r, ys);
   gsl_blas_dgemv(CblasNoTrans, -1.0, Xs, c1, 1.0, r);
   rnorm1 = gsl_blas_dnrm2(r);
-  gsl_test_rel(rnorm0, rnorm1, tol, "test_reg2: %s, rnorm lambda=%g n=%zu p=%zu",
+  gsl_test_rel(rnorm0, rnorm1, tol, "test_reg2: %s, rnorm lambda=%g n="F_ZU" p="F_ZU,
                desc, lambda, n, p);
 
   /* test c0 = c1 */
@@ -169,7 +169,7 @@ test_reg2(const double lambda, const gsl_matrix * X, const gsl_vector * y,
       double c0j = gsl_vector_get(c0, j);
       double c1j = gsl_vector_get(c1, j);
 
-      gsl_test_rel(c1j, c0j, tol, "test_reg2: %s, c0/c1 lambda=%g n=%zu p=%zu",
+      gsl_test_rel(c1j, c0j, tol, "test_reg2: %s, c0/c1 lambda=%g n="F_ZU" p="F_ZU,
                    desc, lambda, n, p);
     }
 
@@ -235,7 +235,7 @@ test_reg3(const double lambda, const gsl_vector * L, const gsl_matrix * X,
   gsl_vector_memcpy(Lc, c1);
   gsl_vector_mul(Lc, L);
   snorm1 = gsl_blas_dnrm2(Lc);
-  gsl_test_rel(snorm0, snorm1, tol, "test_reg3: %s, snorm lambda=%g n=%zu p=%zu",
+  gsl_test_rel(snorm0, snorm1, tol, "test_reg3: %s, snorm lambda=%g n="F_ZU" p="F_ZU,
                desc, lambda, n, p);
 
   /* test rnorm = ||y - X c1||, compute again Xs = sqrt(W) X and ys = sqrt(W) y */
@@ -243,7 +243,7 @@ test_reg3(const double lambda, const gsl_vector * L, const gsl_matrix * X,
   gsl_vector_memcpy(r, ys);
   gsl_blas_dgemv(CblasNoTrans, -1.0, Xs, c1, 1.0, r);
   rnorm1 = gsl_blas_dnrm2(r);
-  gsl_test_rel(rnorm0, rnorm1, tol, "test_reg3: %s, rnorm lambda=%g n=%zu p=%zu",
+  gsl_test_rel(rnorm0, rnorm1, tol, "test_reg3: %s, rnorm lambda=%g n="F_ZU" p="F_ZU,
                desc, lambda, n, p);
 
   /* test c0 = c1 */
@@ -252,7 +252,7 @@ test_reg3(const double lambda, const gsl_vector * L, const gsl_matrix * X,
       double c0j = gsl_vector_get(c0, j);
       double c1j = gsl_vector_get(c1, j);
 
-      gsl_test_rel(c1j, c0j, tol, "test_reg3: %s, c0/c1 j=%zu lambda=%g n=%zu p=%zu",
+      gsl_test_rel(c1j, c0j, tol, "test_reg3: %s, c0/c1 j="F_ZU" lambda=%g n="F_ZU" p="F_ZU,
                    desc, j, lambda, n, p);
     }
 
@@ -340,7 +340,7 @@ test_reg4(const double lambda, const gsl_matrix * L, const gsl_matrix * X,
       double c0j = gsl_vector_get(c0, j);
       double c1j = gsl_vector_get(c1, j);
 
-      gsl_test_rel(c1j, c0j, tol, "test_reg4: %s lambda=%g n=%zu p=%zu j=%zu",
+      gsl_test_rel(c1j, c0j, tol, "test_reg4: %s lambda=%g n="F_ZU" p="F_ZU" j="F_ZU,
                    desc, lambda, n, p, j);
     }
 
@@ -518,7 +518,7 @@ test_reg_sobolev(const size_t p, const size_t kmax, const gsl_rng *r)
               double aij = gsl_matrix_get(LTL, i, j);
               double bij = gsl_matrix_get(LTL2, i, j);
 
-              gsl_test_rel(aij, bij, tol, "sobolov k=%zu LTL(%zu,%zu)", k, i, j);
+              gsl_test_rel(aij, bij, tol, "sobolov k="F_ZU" LTL("F_ZU","F_ZU")", k, i, j);
             }
         }
 
diff --git a/multifit/test_rosenbrock.c b/multifit/test_rosenbrock.c
index d42806e..559351c 100644
--- a/multifit/test_rosenbrock.c
+++ b/multifit/test_rosenbrock.c
@@ -19,7 +19,7 @@ rosenbrock_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rosenbrock_P; ++i)
     {
-      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_rosenbrocke.c b/multifit/test_rosenbrocke.c
index fca65fc..6f3e3c7 100644
--- a/multifit/test_rosenbrocke.c
+++ b/multifit/test_rosenbrocke.c
@@ -23,7 +23,7 @@ rosenbrocke_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rosenbrocke_P; ++i)
     {
-      gsl_test_rel(x[i], rosenbrocke_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rosenbrocke_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_roth.c b/multifit/test_roth.c
index 87f7ae0..c4ec9e1 100644
--- a/multifit/test_roth.c
+++ b/multifit/test_roth.c
@@ -35,7 +35,7 @@ roth_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < roth_P; ++i)
     {
-      gsl_test_rel(x[i], roth_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], roth_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_shaw.c b/multifit/test_shaw.c
index b0120f1..a4529d1 100644
--- a/multifit/test_shaw.c
+++ b/multifit/test_shaw.c
@@ -118,9 +118,9 @@ test_shaw_system(gsl_rng *rng_p, const size_t n, const size_t p,
 
       /* solve regularized system and check for consistent rho/eta values */
       gsl_multifit_linear_solve(lami, X, y, c, &rnorm, &snorm, work);
-      gsl_test_rel(rhoi, rnorm, tol3, "shaw rho n=%zu p=%zu lambda=%e",
+      gsl_test_rel(rhoi, rnorm, tol3, "shaw rho n="F_ZU" p="F_ZU" lambda=%e",
                    n, p, lami);
-      gsl_test_rel(etai, snorm, tol1, "shaw eta n=%zu p=%zu lambda=%e",
+      gsl_test_rel(etai, snorm, tol1, "shaw eta n="F_ZU" p="F_ZU" lambda=%e",
                    n, p, lami);
     }
 
@@ -133,7 +133,7 @@ test_shaw_system(gsl_rng *rng_p, const size_t n, const size_t p,
   if (lambda_expected > 0.0)
     {
       gsl_test_rel(lambda, lambda_expected, tol1,
-                   "shaw: n=%zu p=%zu L-curve corner lambda",
+                   "shaw: n="F_ZU" p="F_ZU" L-curve corner lambda",
                    n, p);
     }
 
@@ -146,11 +146,11 @@ test_shaw_system(gsl_rng *rng_p, const size_t n, const size_t p,
 
   /* test rnorm value */
   gsl_test_rel(rnorm, gsl_blas_dnrm2(r), tol2,
-               "shaw: n=%zu p=%zu rnorm", n, p);
+               "shaw: n="F_ZU" p="F_ZU" rnorm", n, p);
 
   /* test snorm value */
   gsl_test_rel(snorm, gsl_blas_dnrm2(c), tol2,
-               "shaw: n=%zu p=%zu snorm", n, p);
+               "shaw: n="F_ZU" p="F_ZU" snorm", n, p);
 
   gsl_matrix_free(X);
   gsl_matrix_free(cov);
diff --git a/multifit/test_thurber.c b/multifit/test_thurber.c
index fd07309..2eb8d6b 100644
--- a/multifit/test_thurber.c
+++ b/multifit/test_thurber.c
@@ -49,7 +49,7 @@ thurber_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < thurber_P; ++i)
     {
-      gsl_test_rel(x[i], thurber_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], thurber_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_vardim.c b/multifit/test_vardim.c
index 03dda5c..23e880a 100644
--- a/multifit/test_vardim.c
+++ b/multifit/test_vardim.c
@@ -20,7 +20,7 @@ vardim_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < vardim_P; ++i)
     {
-      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_watson.c b/multifit/test_watson.c
index cd7c663..9fd621c 100644
--- a/multifit/test_watson.c
+++ b/multifit/test_watson.c
@@ -22,7 +22,7 @@ watson_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < watson_P; ++i)
     {
-      gsl_test_rel(x[i], watson_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], watson_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_wnlin.c b/multifit/test_wnlin.c
index a11d7b34..ffc0f50 100644
--- a/multifit/test_wnlin.c
+++ b/multifit/test_wnlin.c
@@ -48,7 +48,7 @@ wnlin_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < wnlin_P; ++i)
     {
-      gsl_test_rel(x[i], wnlin_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], wnlin_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit/test_wood.c b/multifit/test_wood.c
index e2b6ad3..871dc68 100644
--- a/multifit/test_wood.c
+++ b/multifit/test_wood.c
@@ -20,7 +20,7 @@ wood_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < wood_P; ++i)
     {
-      gsl_test_rel(x[i], wood_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], wood_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_bard.c b/multifit_nlinear/test_bard.c
index e5eca77..2c28ab82 100644
--- a/multifit_nlinear/test_bard.c
+++ b/multifit_nlinear/test_bard.c
@@ -48,7 +48,7 @@ bard_checksol(const double x[], const double sumsq,
       if (!gsl_finite(bard_x[i]))
         continue;
 
-      gsl_test_rel(x[i], bard_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], bard_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_beale.c b/multifit_nlinear/test_beale.c
index f4bbeb6..5c94c1e 100644
--- a/multifit_nlinear/test_beale.c
+++ b/multifit_nlinear/test_beale.c
@@ -20,7 +20,7 @@ beale_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < beale_P; ++i)
     {
-      gsl_test_rel(x[i], beale_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], beale_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_biggs.c b/multifit_nlinear/test_biggs.c
index 4fae137..0ee10a6 100644
--- a/multifit_nlinear/test_biggs.c
+++ b/multifit_nlinear/test_biggs.c
@@ -21,7 +21,7 @@ biggs_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < biggs_P; ++i)
     {
-      gsl_test_rel(x[i], biggs_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], biggs_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_boxbod.c b/multifit_nlinear/test_boxbod.c
index b2aa2fa..3fe6b35 100644
--- a/multifit_nlinear/test_boxbod.c
+++ b/multifit_nlinear/test_boxbod.c
@@ -29,7 +29,7 @@ boxbod_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < boxbod_P; ++i)
     {
-      gsl_test_rel(x[i], boxbod_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], boxbod_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_brown1.c b/multifit_nlinear/test_brown1.c
index d801770..ccc4630 100644
--- a/multifit_nlinear/test_brown1.c
+++ b/multifit_nlinear/test_brown1.c
@@ -20,7 +20,7 @@ brown1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < brown1_P; ++i)
     {
-      gsl_test_rel(x[i], brown1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], brown1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_brown2.c b/multifit_nlinear/test_brown2.c
index f3994d5..600185b 100644
--- a/multifit_nlinear/test_brown2.c
+++ b/multifit_nlinear/test_brown2.c
@@ -42,7 +42,7 @@ brown2_checksol(const double x[], const double sumsq,
 
   for (i = 1; i < brown2_P - 1; ++i)
     {
-      gsl_test_rel(x[i], alpha, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], alpha, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 
diff --git a/multifit_nlinear/test_brown3.c b/multifit_nlinear/test_brown3.c
index 7965c7b..7e833b7 100644
--- a/multifit_nlinear/test_brown3.c
+++ b/multifit_nlinear/test_brown3.c
@@ -18,7 +18,7 @@ brown3_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < brown3_P; ++i)
     {
-      gsl_test_rel(x[i], brown3_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], brown3_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_eckerle.c b/multifit_nlinear/test_eckerle.c
index 59bdaf7..0e980fa 100644
--- a/multifit_nlinear/test_eckerle.c
+++ b/multifit_nlinear/test_eckerle.c
@@ -59,7 +59,7 @@ eckerle_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < eckerle_P; ++i)
     {
-      gsl_test_rel(new_x[i], eckerle_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(new_x[i], eckerle_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_enso.c b/multifit_nlinear/test_enso.c
index 93fb3ef..ae33ceb 100644
--- a/multifit_nlinear/test_enso.c
+++ b/multifit_nlinear/test_enso.c
@@ -65,7 +65,7 @@ enso_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < enso_P; ++i)
     {
-      gsl_test_rel(x[i], enso_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], enso_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_exp1.c b/multifit_nlinear/test_exp1.c
index 62b9d11..6b2076c 100644
--- a/multifit_nlinear/test_exp1.c
+++ b/multifit_nlinear/test_exp1.c
@@ -30,7 +30,7 @@ exp1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < exp1_P; ++i)
     {
-      gsl_test_rel(x[i], exp1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], exp1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_gaussian.c b/multifit_nlinear/test_gaussian.c
index f2039f8..b899282 100644
--- a/multifit_nlinear/test_gaussian.c
+++ b/multifit_nlinear/test_gaussian.c
@@ -25,7 +25,7 @@ gaussian_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < gaussian_P; ++i)
     {
-      gsl_test_rel(x[i], gaussian_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], gaussian_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_hahn1.c b/multifit_nlinear/test_hahn1.c
index 50fafdd..f34b185 100644
--- a/multifit_nlinear/test_hahn1.c
+++ b/multifit_nlinear/test_hahn1.c
@@ -131,7 +131,7 @@ hahn1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < hahn1_P; ++i)
     {
-      gsl_test_rel(x[i], hahn1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], hahn1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_helical.c b/multifit_nlinear/test_helical.c
index b3b2ef7..5ad880b 100644
--- a/multifit_nlinear/test_helical.c
+++ b/multifit_nlinear/test_helical.c
@@ -19,7 +19,7 @@ helical_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < helical_P; ++i)
     {
-      gsl_test_rel(x[i], helical_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], helical_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_jennrich.c b/multifit_nlinear/test_jennrich.c
index 16a29af..518bdfe 100644
--- a/multifit_nlinear/test_jennrich.c
+++ b/multifit_nlinear/test_jennrich.c
@@ -19,7 +19,7 @@ jennrich_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < jennrich_P; ++i)
     {
-      gsl_test_rel(x[i], jennrich_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], jennrich_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_kirby2.c b/multifit_nlinear/test_kirby2.c
index b0b405f..ad3833b 100644
--- a/multifit_nlinear/test_kirby2.c
+++ b/multifit_nlinear/test_kirby2.c
@@ -95,7 +95,7 @@ kirby2_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < kirby2_P; ++i)
     {
-      gsl_test_rel(x[i], kirby2_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], kirby2_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_kowalik.c b/multifit_nlinear/test_kowalik.c
index 3edbf42..5d24181 100644
--- a/multifit_nlinear/test_kowalik.c
+++ b/multifit_nlinear/test_kowalik.c
@@ -58,7 +58,7 @@ kowalik_checksol(const double x[], const double sumsq,
       if (!gsl_finite(kowalik_x[i]))
         continue;
 
-      gsl_test_rel(x[i], kowalik_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], kowalik_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_lin1.c b/multifit_nlinear/test_lin1.c
index 1cba5da..f6dbe48 100644
--- a/multifit_nlinear/test_lin1.c
+++ b/multifit_nlinear/test_lin1.c
@@ -17,7 +17,7 @@ lin1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < lin1_P; ++i)
     {
-      gsl_test_rel(x[i], -1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], -1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_meyer.c b/multifit_nlinear/test_meyer.c
index 4141b33..a147a14 100644
--- a/multifit_nlinear/test_meyer.c
+++ b/multifit_nlinear/test_meyer.c
@@ -26,7 +26,7 @@ meyer_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < meyer_P; ++i)
     {
-      gsl_test_rel(x[i], meyer_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], meyer_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_meyerscal.c b/multifit_nlinear/test_meyerscal.c
index b0e0934..acca758 100644
--- a/multifit_nlinear/test_meyerscal.c
+++ b/multifit_nlinear/test_meyerscal.c
@@ -26,7 +26,7 @@ meyerscal_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < meyerscal_P; ++i)
     {
-      gsl_test_rel(x[i], meyerscal_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], meyerscal_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_powell1.c b/multifit_nlinear/test_powell1.c
index 0580eb9..5a94829 100644
--- a/multifit_nlinear/test_powell1.c
+++ b/multifit_nlinear/test_powell1.c
@@ -17,7 +17,7 @@ powell1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell1_P; ++i)
     {
-      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_powell2.c b/multifit_nlinear/test_powell2.c
index 08c4a11..040a3e1 100644
--- a/multifit_nlinear/test_powell2.c
+++ b/multifit_nlinear/test_powell2.c
@@ -17,7 +17,7 @@ powell2_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell2_P; ++i)
     {
-      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_powell3.c b/multifit_nlinear/test_powell3.c
index aeb333e..a7427d3 100644
--- a/multifit_nlinear/test_powell3.c
+++ b/multifit_nlinear/test_powell3.c
@@ -19,7 +19,7 @@ powell3_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell3_P; ++i)
     {
-      gsl_test_rel(x[i], powell3_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], powell3_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_rat42.c b/multifit_nlinear/test_rat42.c
index 28ec604..1e866c4 100644
--- a/multifit_nlinear/test_rat42.c
+++ b/multifit_nlinear/test_rat42.c
@@ -32,7 +32,7 @@ rat42_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rat42_P; ++i)
     {
-      gsl_test_rel(x[i], rat42_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rat42_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_rat43.c b/multifit_nlinear/test_rat43.c
index 0831c61..993ed6c 100644
--- a/multifit_nlinear/test_rat43.c
+++ b/multifit_nlinear/test_rat43.c
@@ -32,7 +32,7 @@ rat43_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rat43_P; ++i)
     {
-      gsl_test_rel(x[i], rat43_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rat43_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_rosenbrock.c b/multifit_nlinear/test_rosenbrock.c
index 23f5e7a..d8f12f9 100644
--- a/multifit_nlinear/test_rosenbrock.c
+++ b/multifit_nlinear/test_rosenbrock.c
@@ -17,7 +17,7 @@ rosenbrock_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rosenbrock_P; ++i)
     {
-      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_rosenbrocke.c b/multifit_nlinear/test_rosenbrocke.c
index 97e6168..ad4e87d 100644
--- a/multifit_nlinear/test_rosenbrocke.c
+++ b/multifit_nlinear/test_rosenbrocke.c
@@ -20,7 +20,7 @@ rosenbrocke_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rosenbrocke_P; ++i)
     {
-      gsl_test_rel(x[i], rosenbrocke_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rosenbrocke_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_roth.c b/multifit_nlinear/test_roth.c
index de54ba1..416941e 100644
--- a/multifit_nlinear/test_roth.c
+++ b/multifit_nlinear/test_roth.c
@@ -33,7 +33,7 @@ roth_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < roth_P; ++i)
     {
-      gsl_test_rel(x[i], roth_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], roth_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_thurber.c b/multifit_nlinear/test_thurber.c
index 4eb38df..4640c8e 100644
--- a/multifit_nlinear/test_thurber.c
+++ b/multifit_nlinear/test_thurber.c
@@ -48,7 +48,7 @@ thurber_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < thurber_P; ++i)
     {
-      gsl_test_rel(x[i], thurber_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], thurber_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_vardim.c b/multifit_nlinear/test_vardim.c
index 5074b36..a35e830 100644
--- a/multifit_nlinear/test_vardim.c
+++ b/multifit_nlinear/test_vardim.c
@@ -17,7 +17,7 @@ vardim_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < vardim_P; ++i)
     {
-      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_watson.c b/multifit_nlinear/test_watson.c
index ea26ad4..606be58 100644
--- a/multifit_nlinear/test_watson.c
+++ b/multifit_nlinear/test_watson.c
@@ -20,7 +20,7 @@ watson_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < watson_P; ++i)
     {
-      gsl_test_rel(x[i], watson_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], watson_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_wnlin.c b/multifit_nlinear/test_wnlin.c
index c971092..f74b27e 100644
--- a/multifit_nlinear/test_wnlin.c
+++ b/multifit_nlinear/test_wnlin.c
@@ -48,7 +48,7 @@ wnlin_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < wnlin_P; ++i)
     {
-      gsl_test_rel(x[i], wnlin_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], wnlin_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multifit_nlinear/test_wood.c b/multifit_nlinear/test_wood.c
index c114a39..8838071 100644
--- a/multifit_nlinear/test_wood.c
+++ b/multifit_nlinear/test_wood.c
@@ -18,7 +18,7 @@ wood_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < wood_P; ++i)
     {
-      gsl_test_rel(x[i], wood_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], wood_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge/test.c b/multilarge/test.c
index 02651e5..8600dd1 100644
--- a/multilarge/test.c
+++ b/multilarge/test.c
@@ -180,7 +180,7 @@ test_compare_vectors(const double tol, const gsl_vector * a,
       double ai = gsl_vector_get(a, i);
       double bi = gsl_vector_get(b, i);
 
-      gsl_test_rel(bi, ai, tol, "%s i=%zu", desc, i);
+      gsl_test_rel(bi, ai, tol, "%s i="F_ZU, desc, i);
     }
 }
 
@@ -386,7 +386,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, NULL, NULL, NULL, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, NULL, NULL, NULL, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s unweighted stdform n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s unweighted stdform n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
@@ -399,7 +399,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, w, diagL, NULL, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, w, diagL, NULL, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s weighted diag(L) n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s weighted diag(L) n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
@@ -412,7 +412,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, NULL, diagL, NULL, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, NULL, diagL, NULL, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s unweighted diag(L) n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s unweighted diag(L) n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
@@ -425,7 +425,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, w, NULL, Lsqr, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, w, NULL, Lsqr, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s weighted Lsqr n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s weighted Lsqr n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
@@ -438,7 +438,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, NULL, NULL, Lsqr, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, NULL, NULL, Lsqr, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s unweighted Lsqr n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s unweighted Lsqr n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
@@ -451,7 +451,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, w, NULL, Ltall, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, w, NULL, Ltall, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s weighted Ltall n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s weighted Ltall n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
@@ -464,7 +464,7 @@ test_random(const gsl_multilarge_linear_type * T,
         test_multifit_solve(lambda, X, y, NULL, NULL, Ltall, &rnorm0, &snorm0, c0);
         test_multilarge_solve(T, lambda, X, y, NULL, NULL, Ltall, &rnorm1, &snorm1, c1);
 
-        sprintf(str, "random %s unweighted Ltall n=%zu p=%zu lambda=%g",
+        sprintf(str, "random %s unweighted Ltall n="F_ZU" p="F_ZU" lambda=%g",
                 T->name, n, p, lambda);
         test_compare_vectors(tol, c0, c1, str);
 
diff --git a/multilarge_nlinear/test_bard.c b/multilarge_nlinear/test_bard.c
index c3c74ab..c7192b7 100644
--- a/multilarge_nlinear/test_bard.c
+++ b/multilarge_nlinear/test_bard.c
@@ -47,7 +47,7 @@ bard_checksol(const double x[], const double sumsq,
       if (!gsl_finite(bard_x[i]))
         continue;
 
-      gsl_test_rel(x[i], bard_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], bard_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_beale.c b/multilarge_nlinear/test_beale.c
index d7f6ab6..108c9c4 100644
--- a/multilarge_nlinear/test_beale.c
+++ b/multilarge_nlinear/test_beale.c
@@ -22,7 +22,7 @@ beale_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < beale_P; ++i)
     {
-      gsl_test_rel(x[i], beale_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], beale_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_boxbod.c b/multilarge_nlinear/test_boxbod.c
index 9454aa9..085986a 100644
--- a/multilarge_nlinear/test_boxbod.c
+++ b/multilarge_nlinear/test_boxbod.c
@@ -31,7 +31,7 @@ boxbod_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < boxbod_P; ++i)
     {
-      gsl_test_rel(x[i], boxbod_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], boxbod_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_brown1.c b/multilarge_nlinear/test_brown1.c
index 167c7c0..0213e2a 100644
--- a/multilarge_nlinear/test_brown1.c
+++ b/multilarge_nlinear/test_brown1.c
@@ -22,7 +22,7 @@ brown1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < brown1_P; ++i)
     {
-      gsl_test_rel(x[i], brown1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], brown1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_brown2.c b/multilarge_nlinear/test_brown2.c
index b454277..596b2c2 100644
--- a/multilarge_nlinear/test_brown2.c
+++ b/multilarge_nlinear/test_brown2.c
@@ -44,7 +44,7 @@ brown2_checksol(const double x[], const double sumsq,
 
   for (i = 1; i < brown2_P - 1; ++i)
     {
-      gsl_test_rel(x[i], alpha, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], alpha, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 
diff --git a/multilarge_nlinear/test_brown3.c b/multilarge_nlinear/test_brown3.c
index 5303595..f53b9e8 100644
--- a/multilarge_nlinear/test_brown3.c
+++ b/multilarge_nlinear/test_brown3.c
@@ -20,7 +20,7 @@ brown3_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < brown3_P; ++i)
     {
-      gsl_test_rel(x[i], brown3_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], brown3_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_eckerle.c b/multilarge_nlinear/test_eckerle.c
index 326a08e..f04ad54 100644
--- a/multilarge_nlinear/test_eckerle.c
+++ b/multilarge_nlinear/test_eckerle.c
@@ -61,7 +61,7 @@ eckerle_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < eckerle_P; ++i)
     {
-      gsl_test_rel(new_x[i], eckerle_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(new_x[i], eckerle_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_enso.c b/multilarge_nlinear/test_enso.c
index 9cc3e1a..d743182 100644
--- a/multilarge_nlinear/test_enso.c
+++ b/multilarge_nlinear/test_enso.c
@@ -66,7 +66,7 @@ enso_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < enso_P; ++i)
     {
-      gsl_test_rel(x[i], enso_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], enso_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_exp1.c b/multilarge_nlinear/test_exp1.c
index 7455bd6..3a0c527 100644
--- a/multilarge_nlinear/test_exp1.c
+++ b/multilarge_nlinear/test_exp1.c
@@ -32,7 +32,7 @@ exp1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < exp1_P; ++i)
     {
-      gsl_test_rel(x[i], exp1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], exp1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_gaussian.c b/multilarge_nlinear/test_gaussian.c
index db48192..8eed673 100644
--- a/multilarge_nlinear/test_gaussian.c
+++ b/multilarge_nlinear/test_gaussian.c
@@ -27,7 +27,7 @@ gaussian_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < gaussian_P; ++i)
     {
-      gsl_test_rel(x[i], gaussian_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], gaussian_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_hahn1.c b/multilarge_nlinear/test_hahn1.c
index 9cbf133..0500dae 100644
--- a/multilarge_nlinear/test_hahn1.c
+++ b/multilarge_nlinear/test_hahn1.c
@@ -132,7 +132,7 @@ hahn1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < hahn1_P; ++i)
     {
-      gsl_test_rel(x[i], hahn1_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], hahn1_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_helical.c b/multilarge_nlinear/test_helical.c
index 0e7f646..c26d692 100644
--- a/multilarge_nlinear/test_helical.c
+++ b/multilarge_nlinear/test_helical.c
@@ -20,7 +20,7 @@ helical_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < helical_P; ++i)
     {
-      gsl_test_rel(x[i], helical_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], helical_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_jennrich.c b/multilarge_nlinear/test_jennrich.c
index 3a43504..2918589 100644
--- a/multilarge_nlinear/test_jennrich.c
+++ b/multilarge_nlinear/test_jennrich.c
@@ -21,7 +21,7 @@ jennrich_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < jennrich_P; ++i)
     {
-      gsl_test_rel(x[i], jennrich_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], jennrich_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_kirby2.c b/multilarge_nlinear/test_kirby2.c
index 3aeedae..3d6b1b8 100644
--- a/multilarge_nlinear/test_kirby2.c
+++ b/multilarge_nlinear/test_kirby2.c
@@ -96,7 +96,7 @@ kirby2_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < kirby2_P; ++i)
     {
-      gsl_test_rel(x[i], kirby2_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], kirby2_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_kowalik.c b/multilarge_nlinear/test_kowalik.c
index 0cef546..c6affa3 100644
--- a/multilarge_nlinear/test_kowalik.c
+++ b/multilarge_nlinear/test_kowalik.c
@@ -56,7 +56,7 @@ kowalik_checksol(const double x[], const double sumsq,
       if (!gsl_finite(kowalik_x[i]))
         continue;
 
-      gsl_test_rel(x[i], kowalik_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], kowalik_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_lin1.c b/multilarge_nlinear/test_lin1.c
index f488399..e676aaf 100644
--- a/multilarge_nlinear/test_lin1.c
+++ b/multilarge_nlinear/test_lin1.c
@@ -19,7 +19,7 @@ lin1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < lin1_P; ++i)
     {
-      gsl_test_rel(x[i], -1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], -1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_meyer.c b/multilarge_nlinear/test_meyer.c
index 29210b5..33acac6 100644
--- a/multilarge_nlinear/test_meyer.c
+++ b/multilarge_nlinear/test_meyer.c
@@ -28,7 +28,7 @@ meyer_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < meyer_P; ++i)
     {
-      gsl_test_rel(x[i], meyer_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], meyer_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_meyerscal.c b/multilarge_nlinear/test_meyerscal.c
index 3d33765..6dc7767 100644
--- a/multilarge_nlinear/test_meyerscal.c
+++ b/multilarge_nlinear/test_meyerscal.c
@@ -28,7 +28,7 @@ meyerscal_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < meyerscal_P; ++i)
     {
-      gsl_test_rel(x[i], meyerscal_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], meyerscal_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_powell1.c b/multilarge_nlinear/test_powell1.c
index 080c21b..4ff9f8f 100644
--- a/multilarge_nlinear/test_powell1.c
+++ b/multilarge_nlinear/test_powell1.c
@@ -19,7 +19,7 @@ powell1_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell1_P; ++i)
     {
-      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_powell2.c b/multilarge_nlinear/test_powell2.c
index 4293c49..a37b87b 100644
--- a/multilarge_nlinear/test_powell2.c
+++ b/multilarge_nlinear/test_powell2.c
@@ -19,7 +19,7 @@ powell2_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell2_P; ++i)
     {
-      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 0.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_powell3.c b/multilarge_nlinear/test_powell3.c
index 3bd414f..d71e019 100644
--- a/multilarge_nlinear/test_powell3.c
+++ b/multilarge_nlinear/test_powell3.c
@@ -21,7 +21,7 @@ powell3_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < powell3_P; ++i)
     {
-      gsl_test_rel(x[i], powell3_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], powell3_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_rat42.c b/multilarge_nlinear/test_rat42.c
index d147eda..f5b05cc 100644
--- a/multilarge_nlinear/test_rat42.c
+++ b/multilarge_nlinear/test_rat42.c
@@ -34,7 +34,7 @@ rat42_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rat42_P; ++i)
     {
-      gsl_test_rel(x[i], rat42_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rat42_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_rat43.c b/multilarge_nlinear/test_rat43.c
index 00e3dca..3693301 100644
--- a/multilarge_nlinear/test_rat43.c
+++ b/multilarge_nlinear/test_rat43.c
@@ -34,7 +34,7 @@ rat43_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rat43_P; ++i)
     {
-      gsl_test_rel(x[i], rat43_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rat43_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_rosenbrock.c b/multilarge_nlinear/test_rosenbrock.c
index 3925a3c..55c3246 100644
--- a/multilarge_nlinear/test_rosenbrock.c
+++ b/multilarge_nlinear/test_rosenbrock.c
@@ -19,7 +19,7 @@ rosenbrock_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rosenbrock_P; ++i)
     {
-      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_rosenbrocke.c b/multilarge_nlinear/test_rosenbrocke.c
index f5a330f..d7c7ad7 100644
--- a/multilarge_nlinear/test_rosenbrocke.c
+++ b/multilarge_nlinear/test_rosenbrocke.c
@@ -22,7 +22,7 @@ rosenbrocke_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < rosenbrocke_P; ++i)
     {
-      gsl_test_rel(x[i], rosenbrocke_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], rosenbrocke_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_roth.c b/multilarge_nlinear/test_roth.c
index 41d81e3..4596702 100644
--- a/multilarge_nlinear/test_roth.c
+++ b/multilarge_nlinear/test_roth.c
@@ -35,7 +35,7 @@ roth_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < roth_P; ++i)
     {
-      gsl_test_rel(x[i], roth_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], roth_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_thurber.c b/multilarge_nlinear/test_thurber.c
index 68bee23..86bd9f7 100644
--- a/multilarge_nlinear/test_thurber.c
+++ b/multilarge_nlinear/test_thurber.c
@@ -50,7 +50,7 @@ thurber_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < thurber_P; ++i)
     {
-      gsl_test_rel(x[i], thurber_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], thurber_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_vardim.c b/multilarge_nlinear/test_vardim.c
index 18521c8..753ad4a 100644
--- a/multilarge_nlinear/test_vardim.c
+++ b/multilarge_nlinear/test_vardim.c
@@ -19,7 +19,7 @@ vardim_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < vardim_P; ++i)
     {
-      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], 1.0, epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_watson.c b/multilarge_nlinear/test_watson.c
index b7063f5..5d312e4 100644
--- a/multilarge_nlinear/test_watson.c
+++ b/multilarge_nlinear/test_watson.c
@@ -22,7 +22,7 @@ watson_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < watson_P; ++i)
     {
-      gsl_test_rel(x[i], watson_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], watson_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_wnlin.c b/multilarge_nlinear/test_wnlin.c
index 9f5a661..35247ff 100644
--- a/multilarge_nlinear/test_wnlin.c
+++ b/multilarge_nlinear/test_wnlin.c
@@ -46,7 +46,7 @@ wnlin_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < wnlin_P; ++i)
     {
-      gsl_test_rel(x[i], wnlin_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], wnlin_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/multilarge_nlinear/test_wood.c b/multilarge_nlinear/test_wood.c
index 6d6d126..1907a76 100644
--- a/multilarge_nlinear/test_wood.c
+++ b/multilarge_nlinear/test_wood.c
@@ -20,7 +20,7 @@ wood_checksol(const double x[], const double sumsq,
 
   for (i = 0; i < wood_P; ++i)
     {
-      gsl_test_rel(x[i], wood_x[i], epsrel, "%s/%s i=%zu",
+      gsl_test_rel(x[i], wood_x[i], epsrel, "%s/%s i="F_ZU,
                    sname, pname, i);
     }
 }
diff --git a/rstat/test.c b/rstat/test.c
index d226ab5..15e8fd7 100644
--- a/rstat/test.c
+++ b/rstat/test.c
@@ -72,12 +72,12 @@ test_basic(const size_t n, const double data[], const double tol)
   skew = gsl_rstat_skew(rstat_workspace_p);
   kurtosis = gsl_rstat_kurtosis(rstat_workspace_p);
 
-  gsl_test_rel(mean, expected_mean, tol, "mean n=%zu", n);
-  gsl_test_rel(var, expected_var, tol, "variance n=%zu", n);
-  gsl_test_rel(sd, expected_sd, tol, "stddev n=%zu", n);
-  gsl_test_rel(rms, expected_rms, tol, "rms n=%zu", n);
-  gsl_test_rel(skew, expected_skew, tol, "skew n=%zu", n);
-  gsl_test_rel(kurtosis, expected_kurtosis, tol, "kurtosis n=%zu", n);
+  gsl_test_rel(mean, expected_mean, tol, "mean n="F_ZU, n);
+  gsl_test_rel(var, expected_var, tol, "variance n="F_ZU, n);
+  gsl_test_rel(sd, expected_sd, tol, "stddev n="F_ZU, n);
+  gsl_test_rel(rms, expected_rms, tol, "rms n="F_ZU, n);
+  gsl_test_rel(skew, expected_skew, tol, "skew n="F_ZU, n);
+  gsl_test_rel(kurtosis, expected_kurtosis, tol, "kurtosis n="F_ZU, n);
 
   gsl_rstat_free(rstat_workspace_p);
 }
diff --git a/spblas/test.c b/spblas/test.c
index 0c2637d..f70e2c6 100644
--- a/spblas/test.c
+++ b/spblas/test.c
@@ -98,7 +98,7 @@ test_vectors(gsl_vector *observed, gsl_vector *expected, const double tol,
       double x_obs = gsl_vector_get(observed, i);
       double x_exp = gsl_vector_get(expected, i);
 
-      gsl_test_rel(x_obs, x_exp, tol, "N=%zu i=%zu %s", N, i, str);
+      gsl_test_rel(x_obs, x_exp, tol, "N="F_ZU" i="F_ZU" %s", N, i, str);
     }
 
   return s;
diff --git a/specfunc/test_legendre.c b/specfunc/test_legendre.c
index 3fb8e10..800a0e7 100644
--- a/specfunc/test_legendre.c
+++ b/specfunc/test_legendre.c
@@ -127,7 +127,7 @@ test_value(const size_t lmax, const size_t l, const size_t m,
 
   value = p[idx];
 
-  gsl_test_rel(value, expected, tol, "%s %s lmax=%zu l=%zu m=%zu", desc, desc2, lmax, l, m);
+  gsl_test_rel(value, expected, tol, "%s %s lmax="F_ZU" l="F_ZU" m="F_ZU, desc, desc2, lmax, l, m);
 } /* test_value() */
 
 /* Y_{lm} = factor * S_{lm} */
@@ -174,7 +174,7 @@ test_legendre_compare(const size_t lmax, const double *p_expected,
             continue;
 
           gsl_test_rel(p[idx] / fac, p_expected[idx], 1.0e-10,
-                       "%s %s l=%zu m=%zu", desc, desc2, l, m);
+                       "%s %s l="F_ZU" m="F_ZU, desc, desc2, l, m);
         }
     }
 
@@ -247,7 +247,7 @@ test_legendre_schmidt(const size_t lmax, const double csphase, const char *desc)
           double rhs = 1.0;
 
           gsl_test_rel(sum, rhs, 1.0e-10,
-                       "%s l=%zu, x=%f, sum=%.12e", desc, l, x, sum);
+                       "%s l="F_ZU", x=%f, sum=%.12e", desc, l, x, sum);
         }
     }
 
@@ -267,12 +267,12 @@ test_legendre_schmidt(const size_t lmax, const double csphase, const char *desc)
             continue;
 
           /* check p = p_alt = p2 */
-          gsl_test_rel(p[i], p2[i], 1.0e-10, "%s deriv i=%zu", desc, i);
-          gsl_test_rel(p_alt[i], p2[i], 1.0e-10, "%s deriv_alt i=%zu", desc, i);
+          gsl_test_rel(p[i], p2[i], 1.0e-10, "%s deriv i="F_ZU, desc, i);
+          gsl_test_rel(p_alt[i], p2[i], 1.0e-10, "%s deriv_alt i="F_ZU, desc, i);
 
           /* check dp = -1/u*dp_alt */
           gsl_test_rel(-uinv * dp_alt[i], dp[i], 1.0e-10,
-                       "%s deriv_alt x=%f i=%zu", desc, x, i);
+                       "%s deriv_alt x=%f i="F_ZU, desc, x, i);
         }
 
       for (l = 0; l <= lmax; ++l)
@@ -280,7 +280,7 @@ test_legendre_schmidt(const size_t lmax, const double csphase, const char *desc)
           double sum = test_legendre_sum_deriv(l, p, dp);
 
           gsl_test_abs(sum, 0.0, 1.0e-10,
-                       "%s deriv l=%zu, x=%f, sum=%.12e", desc, l, x, sum);
+                       "%s deriv l="F_ZU", x=%f, sum=%.12e", desc, l, x, sum);
         }
     }
 
@@ -296,7 +296,7 @@ test_legendre_schmidt(const size_t lmax, const double csphase, const char *desc)
           if (fabs(p2[i]) < GSL_DBL_MIN)
             continue;
 
-          gsl_test_rel(p[i], p2[i], 1.0e-10, "%s deriv2 i=%zu", desc, i);
+          gsl_test_rel(p[i], p2[i], 1.0e-10, "%s deriv2 i="F_ZU, desc, i);
         }
 
       for (l = 0; l <= lmax; ++l)
@@ -305,9 +305,9 @@ test_legendre_schmidt(const size_t lmax, const double csphase, const char *desc)
           double sum2 = test_legendre_sum_deriv2(l, p, dp, d2p);
 
           gsl_test_abs(sum, 0.0, 1.0e-10,
-                       "%s deriv2 l=%zu, x=%f, sum=%.12e", desc, l, x, sum);
+                       "%s deriv2 l="F_ZU", x=%f, sum=%.12e", desc, l, x, sum);
           gsl_test_abs(sum2, 0.0, 1.0e-6,
-                       "%s deriv2 l=%zu, x=%f, sum=%.12e", desc, l, x, sum2);
+                       "%s deriv2 l="F_ZU", x=%f, sum=%.12e", desc, l, x, sum2);
         }
     }
 
@@ -459,11 +459,11 @@ test_legendre_unnorm(const size_t lmax_orig, const char *desc)
           /* test S(l,0) = P(l,0) */
           idx = gsl_sf_legendre_array_index(l, 0);
           gsl_test_rel(p[idx], p_schmidt[idx], 1.0e-10,
-                       "unnorm l=%zu, m=0, x=%f", l, x);
+                       "unnorm l="F_ZU", m=0, x=%f", l, x);
           gsl_test_rel(dp[idx], dp_schmidt[idx], 1.0e-10,
-                       "unnorm deriv l=%zu, m=0, x=%f", l, x);
+                       "unnorm deriv l="F_ZU", m=0, x=%f", l, x);
           gsl_test_rel(d2p[idx], d2p_schmidt[idx], 1.0e-10,
-                       "unnorm deriv2 l=%zu, m=0, x=%f", l, x);
+                       "unnorm deriv2 l="F_ZU", m=0, x=%f", l, x);
 
           /* test S(l,m) = a_{lm} * P(l,m) for m > 0 */
           for (m = 1; m <= l; ++m)
@@ -471,11 +471,11 @@ test_legendre_unnorm(const size_t lmax_orig, const char *desc)
               idx = gsl_sf_legendre_array_index(l, m);
 
               gsl_test_rel(a_lm * p[idx], p_schmidt[idx], 1.0e-9,
-                           "unnorm l=%zu, m=%zu, x=%f", l, m, x);
+                           "unnorm l="F_ZU", m="F_ZU", x=%f", l, m, x);
               gsl_test_abs(a_lm * dp[idx], dp_schmidt[idx], 1.0e-10,
-                           "unnorm deriv l=%zu, m=%zu, x=%f", l, m, x);
+                           "unnorm deriv l="F_ZU", m="F_ZU", x=%f", l, m, x);
               gsl_test_abs(a_lm * d2p[idx], d2p_schmidt[idx], 1.0e-10,
-                           "unnorm deriv2 l=%zu, m=%zu, x=%f", l, m, x);
+                           "unnorm deriv2 l="F_ZU", m="F_ZU", x=%f", l, m, x);
 
               a_lm /= sqrt((double) (l + m + 1)) *
                       sqrt((double) (l - m));
@@ -490,7 +490,7 @@ test_legendre_unnorm(const size_t lmax_orig, const char *desc)
             {
               size_t idx = gsl_sf_legendre_array_index(l, m);
               gsl_test_rel(p2[idx], p[idx], 1.0e-10,
-                           "%s compare l=%zu, m=%zu, x=%f",
+                           "%s compare l="F_ZU", m="F_ZU", x=%f",
                            desc, l, m, x);
             }
         }
diff --git a/splinalg/test.c b/splinalg/test.c
index d608822..09811bc 100644
--- a/splinalg/test.c
+++ b/splinalg/test.c
@@ -158,7 +158,7 @@ test_poisson(const size_t N, const double epsrel, const int compress)
     }
   while (status == GSL_CONTINUE && ++iter < max_iter);
 
-  gsl_test(status, "%s poisson status s=%d N=%zu", desc, status, N);
+  gsl_test(status, "%s poisson status s=%d N="F_ZU, desc, status, N);
 
   /* check solution against analytic */
   for (i = 0; i < n; ++i)
@@ -167,7 +167,7 @@ test_poisson(const size_t N, const double epsrel, const int compress)
       double u_gsl = gsl_vector_get(u, i);
       double u_exact = sin(M_PI * xi);
 
-      gsl_test_rel(u_gsl, u_exact, epsrel, "%s poisson N=%zu i=%zu",
+      gsl_test_rel(u_gsl, u_exact, epsrel, "%s poisson N="F_ZU" i="F_ZU,
                    desc, N, i);
     }
 
@@ -183,7 +183,7 @@ test_poisson(const size_t N, const double epsrel, const int compress)
     normb = gsl_blas_dnrm2(b);
 
     status = (normr <= tol*normb) != 1;
-    gsl_test(status, "%s poisson residual N=%zu normr=%.12e normb=%.12e",
+    gsl_test(status, "%s poisson residual N="F_ZU" normr=%.12e normb=%.12e",
              desc, N, normr, normb);
 
     gsl_vector_free(r);
@@ -257,7 +257,7 @@ test_toeplitz(const size_t N, const double a, const double b,
     }
   while (status == GSL_CONTINUE && ++iter < max_iter);
 
-  gsl_test(status, "%s toeplitz status s=%d N=%zu a=%f b=%f c=%f",
+  gsl_test(status, "%s toeplitz status s=%d N="F_ZU" a=%f b=%f c=%f",
            desc, status, N, a, b, c);
 
   /* check that the residual satisfies ||r|| <= tol*||b|| */
@@ -272,7 +272,7 @@ test_toeplitz(const size_t N, const double a, const double b,
     normb = gsl_blas_dnrm2(rhs);
 
     status = (normr <= tol*normb) != 1;
-    gsl_test(status, "%s toeplitz residual N=%zu a=%f b=%f c=%f normr=%.12e normb=%.12e",
+    gsl_test(status, "%s toeplitz residual N="F_ZU" a=%f b=%f c=%f normr=%.12e normb=%.12e",
              desc, N, a, b, c, normr, normb);
 
     gsl_vector_free(r);
@@ -308,7 +308,7 @@ test_random(const size_t N, const gsl_rng *r, const int compress)
     B = A;
 
   status = gsl_splinalg_itersolve_iterate(B, b, tol, x, w);
-  gsl_test(status, "%s random status s=%d N=%zu", desc, status, N);
+  gsl_test(status, "%s random status s=%d N="F_ZU, desc, status, N);
 
   /* check that the residual satisfies ||r|| <= tol*||b|| */
   {
@@ -322,7 +322,7 @@ test_random(const size_t N, const gsl_rng *r, const int compress)
     normb = gsl_blas_dnrm2(b);
 
     status = (normr <= tol*normb) != 1;
-    gsl_test(status, "%s random residual N=%zu normr=%.12e normb=%.12e",
+    gsl_test(status, "%s random residual N="F_ZU" normr=%.12e normb=%.12e",
              desc, N, normr, normb);
 
     gsl_vector_free(res);
diff --git a/spmatrix/spio.c b/spmatrix/spio.c
index f6cdba1..bb1cad2 100644
--- a/spmatrix/spio.c
+++ b/spmatrix/spio.c
@@ -51,7 +51,7 @@ gsl_spmatrix_fprintf(FILE *stream, const gsl_spmatrix *m,
     }
 
   /* print rows,columns,nnz */
-  status = fprintf(stream, "%zu\t%zu\t%zu\n",
+  status = fprintf(stream, F_ZU"\t"F_ZU"\t"F_ZU"\n",
                    m->size1, m->size2, m->nz);
   if (status < 0)
     {
@@ -64,7 +64,7 @@ gsl_spmatrix_fprintf(FILE *stream, const gsl_spmatrix *m,
 
       for (n = 0; n < m->nz; ++n)
         {
-          status = fprintf(stream, "%zu\t%zu\t", m->i[n] + 1, m->p[n] + 1);
+          status = fprintf(stream, F_ZU"\t"F_ZU"\t", m->i[n] + 1, m->p[n] + 1);
           if (status < 0)
             {
               GSL_ERROR("fprintf failed", GSL_EFAILED);
@@ -91,7 +91,7 @@ gsl_spmatrix_fprintf(FILE *stream, const gsl_spmatrix *m,
         {
           for (p = m->p[j]; p < m->p[j + 1]; ++p)
             {
-              status = fprintf(stream, "%zu\t%zu\t", m->i[p] + 1, j + 1);
+              status = fprintf(stream, F_ZU"\t"F_ZU"\t", m->i[p] + 1, j + 1);
               if (status < 0)
                 {
                   GSL_ERROR("fprintf failed", GSL_EFAILED);
@@ -119,7 +119,7 @@ gsl_spmatrix_fprintf(FILE *stream, const gsl_spmatrix *m,
         {
           for (p = m->p[i]; p < m->p[i + 1]; ++p)
             {
-              status = fprintf(stream, "%zu\t%zu\t", i + 1, m->i[p] + 1);
+              status = fprintf(stream, F_ZU"\t"F_ZU"\t", i + 1, m->i[p] + 1);
               if (status < 0)
                 {
                   GSL_ERROR("fprintf failed", GSL_EFAILED);
@@ -164,7 +164,7 @@ gsl_spmatrix_fscanf(FILE *stream)
       if (*buf == '%')
         continue;
 
-      c = sscanf(buf, "%zu %zu %zu",
+      c = sscanf(buf, F_ZU" "F_ZU" "F_ZU,
                  &size1, &size2, &nz);
       if (c == 3)
         {
@@ -190,7 +190,7 @@ gsl_spmatrix_fscanf(FILE *stream)
 
     while (fgets(buf, 1024, stream) != NULL)
       {
-        int c = sscanf(buf, "%zu %zu %lg", &i, &j, &val);
+        int c = sscanf(buf, F_ZU" "F_ZU" %lg", &i, &j, &val);
         if (c < 3 || (i == 0) || (j == 0))
           {
             GSL_ERROR_NULL ("error in input file format", GSL_EFAILED);
diff --git a/spmatrix/test.c b/spmatrix/test.c
index d39f267..9931b99 100644
--- a/spmatrix/test.c
+++ b/spmatrix/test.c
@@ -125,21 +125,21 @@ test_getset(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status, "test_getset: M=%zu N=%zu _get != _set", M, N);
+    gsl_test(status, "test_getset: M="F_ZU" N="F_ZU" _get != _set", M, N);
 
     /* test setting an element to 0 */
     gsl_spmatrix_set(m, 0, 0, 1.0);
     gsl_spmatrix_set(m, 0, 0, 0.0);
 
     status = gsl_spmatrix_get(m, 0, 0) != 0.0;
-    gsl_test(status, "test_getset: M=%zu N=%zu m(0,0) = %f",
+    gsl_test(status, "test_getset: M="F_ZU" N="F_ZU" m(0,0) = %f",
              M, N, gsl_spmatrix_get(m, 0, 0));
 
     /* test gsl_spmatrix_set_zero() */
     gsl_spmatrix_set(m, 0, 0, 1.0);
     gsl_spmatrix_set_zero(m);
     status = gsl_spmatrix_get(m, 0, 0) != 0.0;
-    gsl_test(status, "test_getset: M=%zu N=%zu set_zero m(0,0) = %f",
+    gsl_test(status, "test_getset: M="F_ZU" N="F_ZU" set_zero m(0,0) = %f",
              M, N, gsl_spmatrix_get(m, 0, 0));
 
     /* resassemble matrix to ensure nz is calculated correctly */
@@ -154,7 +154,7 @@ test_getset(const size_t M, const size_t N,
       }
 
     status = gsl_spmatrix_nnz(m) != M * N;
-    gsl_test(status, "test_getset: M=%zu N=%zu set_zero nz = %zu",
+    gsl_test(status, "test_getset: M="F_ZU" N="F_ZU" set_zero nz = "F_ZU,
              M, N, gsl_spmatrix_nnz(m));
 
     /* test gsl_spmatrix_ptr() */
@@ -172,7 +172,7 @@ test_getset(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status == 2, "test_getset: M=%zu N=%zu triplet ptr", M, N);
+    gsl_test(status == 2, "test_getset: M="F_ZU" N="F_ZU" triplet ptr", M, N);
 
     gsl_spmatrix_free(m);
   }
@@ -200,11 +200,11 @@ test_getset(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status, "test_getset: duplicate test M=%zu N=%zu _get != _set", M, N);
+    gsl_test(status, "test_getset: duplicate test M="F_ZU" N="F_ZU" _get != _set", M, N);
 
     nnz = gsl_spmatrix_nnz(m);
     status = nnz != expected_nnz;
-    gsl_test(status, "test_getset: duplicate test M=%zu N=%zu nnz=%zu, expected=%zu",
+    gsl_test(status, "test_getset: duplicate test M="F_ZU" N="F_ZU" nnz="F_ZU", expected="F_ZU,
              M, N, nnz, expected_nnz);
 
     gsl_spmatrix_free(m);
@@ -238,8 +238,8 @@ test_getset(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status == 1, "test_getset: M=%zu N=%zu CCS get", M, N);
-    gsl_test(status == 2, "test_getset: M=%zu N=%zu CCS ptr", M, N);
+    gsl_test(status == 1, "test_getset: M="F_ZU" N="F_ZU" CCS get", M, N);
+    gsl_test(status == 2, "test_getset: M="F_ZU" N="F_ZU" CCS ptr", M, N);
 
     gsl_spmatrix_free(T);
     gsl_spmatrix_free(C);
@@ -273,8 +273,8 @@ test_getset(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status == 1, "test_getset: M=%zu N=%zu CRS get", M, N);
-    gsl_test(status == 2, "test_getset: M=%zu N=%zu CRS ptr", M, N);
+    gsl_test(status == 1, "test_getset: M="F_ZU" N="F_ZU" CRS get", M, N);
+    gsl_test(status == 2, "test_getset: M="F_ZU" N="F_ZU" CRS ptr", M, N);
 
     gsl_spmatrix_free(T);
     gsl_spmatrix_free(C);
@@ -297,7 +297,7 @@ test_memcpy(const size_t M, const size_t N,
     gsl_spmatrix_memcpy(B_t, A);
 
     status = gsl_spmatrix_equal(A, B_t) != 1;
-    gsl_test(status, "test_memcpy: _memcpy M=%zu N=%zu triplet format", M, N);
+    gsl_test(status, "test_memcpy: _memcpy M="F_ZU" N="F_ZU" triplet format", M, N);
 
     B_ccs = gsl_spmatrix_alloc_nzmax(M, N, A_ccs->nzmax, GSL_SPMATRIX_CCS);
     B_crs = gsl_spmatrix_alloc_nzmax(M, N, A_ccs->nzmax, GSL_SPMATRIX_CRS);
@@ -306,10 +306,10 @@ test_memcpy(const size_t M, const size_t N,
     gsl_spmatrix_memcpy(B_crs, A_crs);
 
     status = gsl_spmatrix_equal(A_ccs, B_ccs) != 1;
-    gsl_test(status, "test_memcpy: _memcpy M=%zu N=%zu CCS", M, N);
+    gsl_test(status, "test_memcpy: _memcpy M="F_ZU" N="F_ZU" CCS", M, N);
 
     status = gsl_spmatrix_equal(A_crs, B_crs) != 1;
-    gsl_test(status, "test_memcpy: _memcpy M=%zu N=%zu CRS", M, N);
+    gsl_test(status, "test_memcpy: _memcpy M="F_ZU" N="F_ZU" CRS", M, N);
 
     gsl_spmatrix_free(A);
     gsl_spmatrix_free(A_ccs);
@@ -346,7 +346,7 @@ test_memcpy(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status, "test_memcpy: _transpose_memcpy M=%zu N=%zu triplet format", M, N);
+    gsl_test(status, "test_memcpy: _transpose_memcpy M="F_ZU" N="F_ZU" triplet format", M, N);
 
     status = 0;
     for (i = 0; i < M; ++i)
@@ -362,7 +362,7 @@ test_memcpy(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status, "test_memcpy: _transpose_memcpy M=%zu N=%zu CCS format", M, N);
+    gsl_test(status, "test_memcpy: _transpose_memcpy M="F_ZU" N="F_ZU" CCS format", M, N);
 
     status = 0;
     for (i = 0; i < M; ++i)
@@ -378,7 +378,7 @@ test_memcpy(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status, "test_memcpy: _transpose_memcpy M=%zu N=%zu CRS format", M, N);
+    gsl_test(status, "test_memcpy: _transpose_memcpy M="F_ZU" N="F_ZU" CRS format", M, N);
 
     gsl_spmatrix_free(A);
     gsl_spmatrix_free(AT);
@@ -425,9 +425,9 @@ test_transpose(const size_t M, const size_t N,
         }
     }
 
-  gsl_test(status == 1, "test_transpose: transpose M=%zu N=%zu triplet format",
+  gsl_test(status == 1, "test_transpose: transpose M="F_ZU" N="F_ZU" triplet format",
            M, N);
-  gsl_test(status == 2, "test_transpose: transpose2 M=%zu N=%zu triplet format",
+  gsl_test(status == 2, "test_transpose: transpose2 M="F_ZU" N="F_ZU" triplet format",
            M, N);
 
   /* test CCS transpose */
@@ -448,7 +448,7 @@ test_transpose(const size_t M, const size_t N,
         }
     }
 
-  gsl_test(status == 2, "test_transpose: transpose2 M=%zu N=%zu CCS format",
+  gsl_test(status == 2, "test_transpose: transpose2 M="F_ZU" N="F_ZU" CCS format",
            M, N);
 
   /* test CRS transpose */
@@ -469,7 +469,7 @@ test_transpose(const size_t M, const size_t N,
         }
     }
 
-  gsl_test(status == 2, "test_transpose: transpose2 M=%zu N=%zu CRS format",
+  gsl_test(status == 2, "test_transpose: transpose2 M="F_ZU" N="F_ZU" CRS format",
            M, N);
 
   gsl_spmatrix_free(A);
@@ -523,8 +523,8 @@ test_ops(const size_t M, const size_t N,
           }
       }
 
-    gsl_test(status == 1, "test_ops: add M=%zu N=%zu CCS", M, N);
-    gsl_test(status == 2, "test_ops: add M=%zu N=%zu CRS", M, N);
+    gsl_test(status == 1, "test_ops: add M="F_ZU" N="F_ZU" CCS", M, N);
+    gsl_test(status == 2, "test_ops: add M="F_ZU" N="F_ZU" CRS", M, N);
 
     gsl_spmatrix_free(A);
     gsl_spmatrix_free(B);
@@ -566,7 +566,7 @@ test_io_ascii(const size_t M, const size_t N,
     gsl_spmatrix *B = gsl_spmatrix_fscanf(f);
 
     status = gsl_spmatrix_equal(A, B) != 1;
-    gsl_test(status, "test_io_ascii: fprintf/fscanf M=%zu N=%zu triplet format", M, N);
+    gsl_test(status, "test_io_ascii: fprintf/fscanf M="F_ZU" N="F_ZU" triplet format", M, N);
 
     fclose(f);
     gsl_spmatrix_free(B);
@@ -588,7 +588,7 @@ test_io_ascii(const size_t M, const size_t N,
     gsl_spmatrix *B = gsl_spmatrix_fscanf(f);
 
     status = gsl_spmatrix_equal(A, B) != 1;
-    gsl_test(status, "test_io_ascii: fprintf/fscanf M=%zu N=%zu CCS format", M, N);
+    gsl_test(status, "test_io_ascii: fprintf/fscanf M="F_ZU" N="F_ZU" CCS format", M, N);
 
     fclose(f);
     gsl_spmatrix_free(B);
@@ -610,7 +610,7 @@ test_io_ascii(const size_t M, const size_t N,
     gsl_spmatrix *B = gsl_spmatrix_fscanf(f);
 
     status = gsl_spmatrix_equal(A, B) != 1;
-    gsl_test(status, "test_io_ascii: fprintf/fscanf M=%zu N=%zu CRS format", M, N);
+    gsl_test(status, "test_io_ascii: fprintf/fscanf M="F_ZU" N="F_ZU" CRS format", M, N);
 
     fclose(f);
     gsl_spmatrix_free(B);
@@ -653,7 +653,7 @@ test_io_binary(const size_t M, const size_t N,
     gsl_spmatrix_fread(f, B);
 
     status = gsl_spmatrix_equal(A, B) != 1;
-    gsl_test(status, "test_io_binary: fwrite/fread M=%zu N=%zu triplet format", M, N);
+    gsl_test(status, "test_io_binary: fwrite/fread M="F_ZU" N="F_ZU" triplet format", M, N);
 
     fclose(f);
     gsl_spmatrix_free(B);
@@ -677,7 +677,7 @@ test_io_binary(const size_t M, const size_t N,
     gsl_spmatrix_fread(f, B);
 
     status = gsl_spmatrix_equal(A_ccs, B) != 1;
-    gsl_test(status, "test_io_binary: fwrite/fread M=%zu N=%zu CCS format", M, N);
+    gsl_test(status, "test_io_binary: fwrite/fread M="F_ZU" N="F_ZU" CCS format", M, N);
 
     fclose(f);
     gsl_spmatrix_free(B);
@@ -701,7 +701,7 @@ test_io_binary(const size_t M, const size_t N,
     gsl_spmatrix_fread(f, B);
 
     status = gsl_spmatrix_equal(A_crs, B) != 1;
-    gsl_test(status, "test_io_binary: fwrite/fread M=%zu N=%zu CRS format", M, N);
+    gsl_test(status, "test_io_binary: fwrite/fread M="F_ZU" N="F_ZU" CRS format", M, N);
 
     fclose(f);
     gsl_spmatrix_free(B);
-- 
2.10.0

From 136269092823c93bc30a82fa32b518a71c728c4e Mon Sep 17 00:00:00 2001
From: mancoast <RobertPancoast77@gmail.com>
Date: Sat, 17 Dec 2016 12:10:23 -0500
Subject: [PATCH] Comment Dead Code to Enable MSVC14 shared build

---
 multilarge_nlinear/fdf.c                    | 4 ++++
 multilarge_nlinear/gsl_multilarge_nlinear.h | 4 ++++
 2 files changed, 8 insertions(+)

diff --git a/multilarge_nlinear/fdf.c b/multilarge_nlinear/fdf.c
index f35a7c3..c90eb67 100644
--- a/multilarge_nlinear/fdf.c
+++ b/multilarge_nlinear/fdf.c
@@ -502,7 +502,9 @@ gsl_multilarge_nlinear_eval_df(const CBLAS_TRANSPOSE_t TransJ,
         {
 #if 0
           /* use finite difference Jacobian approximation */
+          /*
           status = gsl_multilarge_nlinear_df(h, fdtype, x, swts, fdf, f, df, work);
+          */
 #endif
         }
 
@@ -551,8 +553,10 @@ gsl_multilarge_nlinear_eval_fvv(const double h,
     {
 #if 0
       /* use finite difference approximation */
+      /*
       status = gsl_multilarge_nlinear_fdfvv(h, x, v, f, J,
                                           swts, fdf, yvv, work);
+                                          */
 #endif
     }
 
diff --git a/multilarge_nlinear/gsl_multilarge_nlinear.h b/multilarge_nlinear/gsl_multilarge_nlinear.h
index 51e131b..a243f19 100644
--- a/multilarge_nlinear/gsl_multilarge_nlinear.h
+++ b/multilarge_nlinear/gsl_multilarge_nlinear.h
@@ -275,18 +275,22 @@ gsl_multilarge_nlinear_test (const double xtol, const double gtol,
                              const gsl_multilarge_nlinear_workspace * w);
 
 /* fdjac.c */
+/*
 int
 gsl_multilarge_nlinear_df(const double h, const gsl_multilarge_nlinear_fdtype fdtype,
                           const gsl_vector *x, const gsl_vector *wts,
                           gsl_multilarge_nlinear_fdf *fdf,
                           const gsl_vector *f, gsl_matrix *J, gsl_vector *work);
+						  */
 
 /* fdfvv.c */
+/*
 int
 gsl_multilarge_nlinear_fdfvv(const double h, const gsl_vector *x, const gsl_vector *v,
                              const gsl_vector *f, const gsl_matrix *J,
                              const gsl_vector *swts, gsl_multilarge_nlinear_fdf *fdf,
                              gsl_vector *fvv, gsl_vector *work);
+							 */
 
 /* top-level algorithms */
 GSL_VAR const gsl_multilarge_nlinear_type * gsl_multilarge_nlinear_trust;
-- 
2.10.0

From b16fac86f85e8cfc61139a159e5342e497a0eeaa Mon Sep 17 00:00:00 2001
From: Dilawar Singh <dilawar@users.noreply.github.com>
Date: Fri, 18 Nov 2016 20:09:50 +0530
Subject: [PATCH] Builds gsl-config binary ampl/gsl#11. (#12)

* Builds gsl-config binary ampl/gsl#11.

* Update CMakeLists.txt

Changes as requested in review of PR.
---
 CMakeLists.txt | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8882549..92cb7cb 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -12,6 +12,9 @@ if (POLICY CMP0054)
   # Only interpret `if` arguments as variables or keywords when unquoted.
   cmake_policy(SET CMP0054 NEW)
 endif ()
+if (POLICY CMP0053)
+  cmake_policy(SET CMP0053 NEW)
+endif( )
 
 set(PACKAGE "gsl")
 set(PACKAGE_NAME ${PACKAGE})
@@ -692,4 +695,27 @@ if (GSL_INSTALL OR NOT DEFINED GSL_INSTALL)
   set(PC_FILE ${CMAKE_BINARY_DIR}/gsl.pc)
   configure_file("gsl.pc.cmake" ${PC_FILE} @ONLY)
   install(FILES ${PC_FILE} DESTINATION lib/pkgconfig)
+
+  # Read config file and replace placeholders.
+  file(READ "${CMAKE_SOURCE_DIR}/gsl-config.in" GSL_CONFIG_FILE)
+  string(REPLACE ";" "@SEMICOLON@" GSL_CONFIG_FILE "${GSL_CONFIG_FILE}")
+  # Replace
+  string(REPLACE @prefix@ ${CMAKE_INSTALL_PREFIX} GSL_CONFIG_FILE "${GSL_CONFIG_FILE}")
+  string(REPLACE @exec_prefix@ ${CMAKE_INSTALL_PREFIX}/bin GSL_CONFIG_FILE ${GSL_CONFIG_FILE})
+  string(REPLACE @includedir@ ${CMAKE_INSTALL_PREFIX}/include GSL_CONFIG_FILE
+      "${GSL_CONFIG_FILE}")
+  string(REPLACE @VERSION@ ${VERSION} GSL_CONFIG_FILE "${GSL_CONFIG_FILE}")
+  string(REPLACE @GSL_CFLAGS@ "${CMAKE_C_FLAGS_RELEASE}" GSL_CONFIG_FILE
+      "${GSL_CONFIG_FILE}")
+  string(REPLACE @GSL_LIBS@ "-lgsl -lgslcblas" GSL_CONFIG_FILE
+      "${GSL_CONFIG_FILE}")
+  string(REPLACE @GSL_LIBM@ "-lm" GSL_CONFIG_FILE "${GSL_CONFIG_FILE}")
+
+  # write after putting back ;
+  string(REPLACE "@SEMICOLON@"  "\\;" GSL_CONFIG_FILE "${GSL_CONFIG_FILE}")
+  file(WRITE ${CMAKE_BINARY_DIR}/gsl-config ${GSL_CONFIG_FILE})
+
+  # Install gsl-config
+  install(PROGRAMS ${CMAKE_BINARY_DIR}/gsl-config DESTINATION bin)
+
 endif ()
-- 
2.10.0

From 463833e8cee1802e516e4c177643b49f04564b0b Mon Sep 17 00:00:00 2001
From: mancoast <RobertPancoast77@gmail.com>
Date: Sat, 17 Dec 2016 12:24:25 -0500
Subject: [PATCH] Nuget Development

---
 gsl-msvc14-x64-build.nuget.bat | 68 ++++++++++++++++++++++++++++++++++++++++++
 gsl-msvc14-x64.nuspec          | 15 ++++++++++
 2 files changed, 83 insertions(+)
 create mode 100644 gsl-msvc14-x64-build.nuget.bat
 create mode 100644 gsl-msvc14-x64.nuspec

diff --git a/gsl-msvc14-x64-build.nuget.bat b/gsl-msvc14-x64-build.nuget.bat
new file mode 100644
index 0000000..c3827da
--- /dev/null
+++ b/gsl-msvc14-x64-build.nuget.bat
@@ -0,0 +1,68 @@
+REM @echo off
+
+Echo GSL Windows Build NuGet
+REM set INCREMENTDISABLE=true
+
+REM # XEON x64 Build Vars #
+set _SCRIPT_DRIVE=%~d0
+set _SCRIPT_FOLDER=%~dp0
+set SRC=%CD%
+set BUILDTREE=%SRC%\build-win\
+SET tbs_arch=x64
+SET vcvar_arg=x86_amd64
+SET ms_build_suffix=Bin\amd64
+SET cmake_platform="Visual Studio 14 2015 Win64"
+SET VS14="C:\Program Files (x86)\Microsoft Visual Studio 14.0\"
+SET MSB14="C:\Program Files (x86)\MSBuild\14.0\"
+SET MSBPath=%MSB14%%ms_build_suffix%
+set PATH=%MSBPath%;%SRC%;%PATH%
+
+REM # VC Vars #
+call %VS14%\VC\vcvarsall %vcvar_arg%
+@echo on
+
+REM # Clean Build Tree #
+if defined INCREMENTDISABLE ( 
+	echo "Incremental Build disabled"
+    rd /s /q %BUILDTREE%
+) else (
+	echo "Incremental Build enabled"
+)
+mkdir %BUILDTREE%
+cd %BUILDTREE%
+
+:shared_GSL
+REM # GSL SHARED #
+if exist %BUILDTREE%Release\gsl.lib (
+    if exist %BUILDTREE%Release\gslcblas.lib (
+		ECHO GSL Libs Found
+		GOTO:copy_files
+	)
+)
+
+ECHO %cmake_platform% SHARED
+cmake -G %cmake_platform% ^
+-DBUILD_SHARED_LIBS:BOOL=ON ^
+-DCMAKE_CXX_FLAGS_RELEASE="/MD" ^
+-DCMAKE_CXX_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_C_FLAGS_RELEASE="/MD" ^
+-DCMAKE_C_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_BUILD_TYPE="Release" %SRC%
+msbuild gsl.sln /p:Configuration=Release /m
+
+:copy_files
+set BINDIR=%SRC%\build-nuget\
+echo %BINDIR%
+xcopy %BUILDTREE%Release\gsl* %BINDIR%
+xcopy %BUILDTREE%bin\Release\gsl.dll %BINDIR%
+del %BINDIR%gsl
+xcopy /I %BUILDTREE%gsl %BINDIR%gsl
+
+:nuget_req
+REM # make nuget packages from binaries #
+nuget pack %SRC%\gsl-msvc14-x64.nuspec
+
+GOTO:eof
+
+REM --- exit ----
+GOTO:eof
diff --git a/gsl-msvc14-x64.nuspec b/gsl-msvc14-x64.nuspec
new file mode 100644
index 0000000..21694f7
--- /dev/null
+++ b/gsl-msvc14-x64.nuspec
@@ -0,0 +1,15 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+    <metadata>
+        <id>gsl-msvc14-x64</id>
+        <version>2.2.1.2477</version>
+        <authors>administrator</authors>
+        <requireLicenseAcceptance>false</requireLicenseAcceptance>
+        <description>Release GSL as NuGet package.</description>
+    </metadata>
+    <files>
+        <file src=".\COPYING" target="COPYING" />
+        <file src=".\README" target="README" />
+		<file src=".\build-nuget\**\*.*" target="" />
+    </files>
+</package>
\ No newline at end of file
-- 
2.10.0

From cc42abf50c05aee531c1444f8d878bc9fc62a711 Mon Sep 17 00:00:00 2001
From: mancoast <RobertPancoast77@gmail.com>
Date: Sat, 17 Dec 2016 16:05:56 -0500
Subject: [PATCH] Include Static LIBS in NuGet

---
 gsl-msvc14-x64-build.nuget.bat | 34 +++++++++++++++++++++++++++++++++-
 gsl-msvc14-x64.nuspec          |  2 +-
 2 files changed, 34 insertions(+), 2 deletions(-)

diff --git a/gsl-msvc14-x64-build.nuget.bat b/gsl-msvc14-x64-build.nuget.bat
index c3827da..93f5f27 100644
--- a/gsl-msvc14-x64-build.nuget.bat
+++ b/gsl-msvc14-x64-build.nuget.bat
@@ -1,7 +1,7 @@
 REM @echo off
 
 Echo GSL Windows Build NuGet
-REM set INCREMENTDISABLE=true
+set INCREMENTDISABLE=true
 
 REM # XEON x64 Build Vars #
 set _SCRIPT_DRIVE=%~d0
@@ -52,14 +52,46 @@ msbuild gsl.sln /p:Configuration=Release /m
 
 :copy_files
 set BINDIR=%SRC%\build-nuget\
+rd /s /q %BINDIR%
+mkdir %BINDIR%
 echo %BINDIR%
 xcopy %BUILDTREE%Release\gsl* %BINDIR%
 xcopy %BUILDTREE%bin\Release\gsl.dll %BINDIR%
 del %BINDIR%gsl
 xcopy /I %BUILDTREE%gsl %BINDIR%gsl
 
+mkdir %BUILDTREE%Static
+cd %BUILDTREE%Static
+
+:static_GSL
+REM # GSL STATIC #
+if exist %BUILDTREE%Static\Release\gsl.lib (
+    if exist %BUILDTREE%Static\Release\gslcblas.lib (
+		ECHO GSL Libs Found
+		GOTO:copy_static_files
+	)
+)
+
+ECHO %cmake_platform% STATIC
+cmake -G %cmake_platform% ^
+-DBUILD_SHARED_LIBS:BOOL=OFF ^
+-DCMAKE_CXX_FLAGS_RELEASE="/MD" ^
+-DCMAKE_CXX_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_C_FLAGS_RELEASE="/MD" ^
+-DCMAKE_C_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_BUILD_TYPE="Release" %SRC%
+msbuild gsl.sln /p:Configuration=Release /m
+
+:copy_static_files
+set BINDIR=%SRC%\build-nuget\static
+rd /s /q %BINDIR%
+mkdir %BINDIR%
+echo %BINDIR%
+xcopy %BUILDTREE%Static\Release\gsl* %BINDIR%
+
 :nuget_req
 REM # make nuget packages from binaries #
+cd %BUILDTREE%
 nuget pack %SRC%\gsl-msvc14-x64.nuspec
 
 GOTO:eof
diff --git a/gsl-msvc14-x64.nuspec b/gsl-msvc14-x64.nuspec
index 21694f7..515a539 100644
--- a/gsl-msvc14-x64.nuspec
+++ b/gsl-msvc14-x64.nuspec
@@ -2,7 +2,7 @@
 <package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
     <metadata>
         <id>gsl-msvc14-x64</id>
-        <version>2.2.1.2477</version>
+        <version>2.2.1.2577</version>
         <authors>administrator</authors>
         <requireLicenseAcceptance>false</requireLicenseAcceptance>
         <description>Release GSL as NuGet package.</description>
-- 
2.10.0

From 187ec76980a42b82e0bcfcd5eefb9c0e705f48bc Mon Sep 17 00:00:00 2001
From: mancoast <RobertPancoast77@gmail.com>
Date: Sat, 17 Dec 2016 21:46:27 -0500
Subject: [PATCH] Generate x86 Nuget

---
 gsl-msvc14-x86-build.nuget.bat | 100 +++++++++++++++++++++++++++++++++++++++++
 gsl-msvc14-x86.nuspec          |  15 +++++++
 2 files changed, 115 insertions(+)
 create mode 100644 gsl-msvc14-x86-build.nuget.bat
 create mode 100644 gsl-msvc14-x86.nuspec

diff --git a/gsl-msvc14-x86-build.nuget.bat b/gsl-msvc14-x86-build.nuget.bat
new file mode 100644
index 0000000..65b7120
--- /dev/null
+++ b/gsl-msvc14-x86-build.nuget.bat
@@ -0,0 +1,100 @@
+REM @echo off
+
+Echo GSL Windows Build NuGet
+set INCREMENTDISABLE=true
+
+REM # XEON x86 Build Vars #
+set _SCRIPT_DRIVE=%~d0
+set _SCRIPT_FOLDER=%~dp0
+set SRC=%CD%
+set BUILDTREE=%SRC%\build-win\
+SET tbs_arch=x86
+SET vcvar_arg=x86
+SET ms_build_suffix=Bin
+SET cmake_platform="Visual Studio 14 2015"
+SET VS14="C:\Program Files (x86)\Microsoft Visual Studio 14.0\"
+SET MSB14="C:\Program Files (x86)\MSBuild\14.0\"
+SET MSBPath=%MSB14%%ms_build_suffix%
+set PATH=%MSBPath%;%SRC%;%PATH%
+
+REM # VC Vars #
+call %VS14%\VC\vcvarsall %vcvar_arg%
+@echo on
+
+REM # Clean Build Tree #
+if defined INCREMENTDISABLE ( 
+	echo "Incremental Build disabled"
+    rd /s /q %BUILDTREE%
+) else (
+	echo "Incremental Build enabled"
+)
+mkdir %BUILDTREE%
+cd %BUILDTREE%
+
+:shared_GSL
+REM # GSL SHARED #
+if exist %BUILDTREE%Release\gsl.lib (
+    if exist %BUILDTREE%Release\gslcblas.lib (
+		ECHO GSL Libs Found
+		GOTO:copy_files
+	)
+)
+
+ECHO %cmake_platform% SHARED
+cmake -G %cmake_platform% ^
+-DBUILD_SHARED_LIBS:BOOL=ON ^
+-DCMAKE_CXX_FLAGS_RELEASE="/MD" ^
+-DCMAKE_CXX_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_C_FLAGS_RELEASE="/MD" ^
+-DCMAKE_C_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_BUILD_TYPE="Release" %SRC%
+msbuild gsl.sln /p:Configuration=Release /m
+
+:copy_files
+set BINDIR=%SRC%\build-nuget\
+rd /s /q %BINDIR%
+mkdir %BINDIR%
+echo %BINDIR%
+xcopy %BUILDTREE%Release\gsl* %BINDIR%
+xcopy %BUILDTREE%bin\Release\gsl.dll %BINDIR%
+del %BINDIR%gsl
+xcopy /I %BUILDTREE%gsl %BINDIR%gsl
+
+mkdir %BUILDTREE%Static
+cd %BUILDTREE%Static
+
+:static_GSL
+REM # GSL STATIC #
+if exist %BUILDTREE%Static\Release\gsl.lib (
+    if exist %BUILDTREE%Static\Release\gslcblas.lib (
+		ECHO GSL Libs Found
+		GOTO:copy_static_files
+	)
+)
+
+ECHO %cmake_platform% STATIC
+cmake -G %cmake_platform% ^
+-DBUILD_SHARED_LIBS:BOOL=OFF ^
+-DCMAKE_CXX_FLAGS_RELEASE="/MD" ^
+-DCMAKE_CXX_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_C_FLAGS_RELEASE="/MD" ^
+-DCMAKE_C_FLAGS_DEBUG="/MDd" ^
+-DCMAKE_BUILD_TYPE="Release" %SRC%
+msbuild gsl.sln /p:Configuration=Release /m
+
+:copy_static_files
+set BINDIR=%SRC%\build-nuget\static
+rd /s /q %BINDIR%
+mkdir %BINDIR%
+echo %BINDIR%
+xcopy %BUILDTREE%Static\Release\gsl* %BINDIR%
+
+:nuget_req
+REM # make nuget packages from binaries #
+cd %BUILDTREE%
+nuget pack %SRC%\gsl-msvc14-x86.nuspec
+
+GOTO:eof
+
+REM --- exit ----
+GOTO:eof
diff --git a/gsl-msvc14-x86.nuspec b/gsl-msvc14-x86.nuspec
new file mode 100644
index 0000000..3ce72a0
--- /dev/null
+++ b/gsl-msvc14-x86.nuspec
@@ -0,0 +1,15 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+    <metadata>
+        <id>gsl-msvc14-x86</id>
+        <version>2.2.1.2577</version>
+        <authors>administrator</authors>
+        <requireLicenseAcceptance>false</requireLicenseAcceptance>
+        <description>Release GSL as NuGet package.</description>
+    </metadata>
+    <files>
+        <file src=".\COPYING" target="COPYING" />
+        <file src=".\README" target="README" />
+		<file src=".\build-nuget\**\*.*" target="" />
+    </files>
+</package>
\ No newline at end of file
-- 
2.10.0

